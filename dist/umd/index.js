var __awaiter=this&&this.__awaiter||function(e,t,o,n){return new(o||(o=Promise))(function(r,i){function a(e){try{s(n.next(e))}catch(e){i(e)}}function c(e){try{s(n.throw(e))}catch(e){i(e)}}function s(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o(function(e){e(t)})).then(a,c)}s((n=n.apply(e,t||[])).next())})};!function(e){if("object"==typeof module&&"object"==typeof module.exports){var t=e(require,exports);void 0!==t&&(module.exports=t)}else"function"==typeof define&&define.amd&&define(["require","exports","@ethersproject/contracts","@ethersproject/providers","./utils/store","./utils/builtin","./utils/index.js","./utils/ethers","named-logs","./errors"],e)}(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=e("@ethersproject/contracts"),n=e("@ethersproject/providers"),r=e("./utils/store"),i=e("./utils/builtin"),a=e("./utils/index.js"),c=e("./utils/ethers"),s=e("named-logs"),d=e("./errors"),l=s.logs("web3w:index"),u="undefined"!=typeof window,g={state:"Idle",probing:!1,available:void 0,error:void 0,vendor:void 0},f={state:"Idle",fetching:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},h={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},v={state:"Idle",connecting:!1,disconnecting:!1,loadingModule:!1,unlocking:!1,address:void 0,options:["builtin"],selected:void 0,pendingUserConfirmation:void 0,error:void 0},m={inProgress:!1,executing:!1,executionError:void 0,error:void 0};function b(e){const t=r.writable(e);return t.data=e,t}const w=[],p=b(v),I=b(w),y=b(g),C=b(h),k=b(f),x=b(m);let _="_web3w_transactions",S="_web3w_previous_wallet_type";function E(e,t){for(const o of Object.keys(t)){const n=t,r=e;if(r.data[o]&&"object"==typeof n[o])for(const e of Object.keys(n[o]))r.data[o][e]=n[o][e];else r.data[o]=n[o]}try{l.debug(JSON.stringify(e.data,null,"  "))}catch(t){l.error(t,e.data)}e.set(e.data)}let P,N,R,L,T,A,O,j,D,U,$,q=!1;function H(e){return __awaiter(this,void 0,void 0,function*(){if("0xNaN"===e){if(l.warn("onChainChanged bug (return 0xNaN), metamask bug?"),!N)throw new Error("no web3Provider to get chainId");e=yield W(N,"eth_chainId")}const t=parseInt(e.slice(2),16).toString();l.debug("onChainChanged",{chainId:e,chainIdAsDecimal:t}),E(C,{contracts:void 0,addresses:void 0,state:"Connected",chainId:t,notSupported:void 0}),v.address&&(Ce(v.address,t),l.log("LOAD_CHAIN from chainChanged"),yield te(t,v.address,!0))})}function M(e){return e[0]!==v.address}function B(e){return __awaiter(this,void 0,void 0,function*(){if(!M(e))return void l.debug("false account changed",e);l.debug("onAccountsChanged",{accounts:e});const t=e[0];if(t)if(E(p,{address:t,state:"Ready"}),h.chainId&&Ce(t,h.chainId),"Connected"===h.state){if(!h.chainId)throw new Error("no chainId while connected");l.log("LOAD_CHAIN from accountsChanged"),yield te(h.chainId,t,!1)}else ne(t);else ye(),E(p,{address:t,state:"Locked"}),ne(t)})}function W(e,t,o){var n;if(e.request)return e.request({method:t,params:o});const r=null===(n=e.sendAsync)||void 0===n?void 0:n.bind(e);if(r)return new Promise((e,n)=>{r({method:t,params:o},(t,o)=>{t?n(t):o.error?n(o.error):e(o.result)})});throw new Error("provider not supported")}function G(e){return new Promise(t=>{setTimeout(t,e)})}function J(e,t){return __awaiter(this,void 0,void 0,function*(){for(;q;){let o=[];try{o=yield W(e,"eth_accounts")}catch(e){}if(l.debug({accounts:o}),q&&M(o))try{t(o)}catch(e){l.error(e)}yield G(3e3)}})}function F(){N&&!q&&(l.log("LISTENNING"),N.on?(N.on("chainChanged",H),N.on("accountsChanged",B),J(N,B)):(!function(e,t){__awaiter(this,void 0,void 0,function*(){for(;q;){const o=yield W(e,"eth_chainId"),n=parseInt(o.slice(2),16).toString();if(q&&h.chainId!==n)try{t(o)}catch(e){l.error(e)}yield G(3e3)}})}(N,H),J(N,B)),q=!0)}function z(e){const t=e&&e.chainId;if(t){const e=parseInt(t.slice(2),16).toString();l.debug("onConnect",{chainId:t,chainIdAsDecimal:e})}else l.warn("onConnect","no connection object passed in")}function V(e){l.debug("onDisconnect",{error:e})}function Y(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function X(e){v.pendingUserConfirmation?v.pendingUserConfirmation.push(e):v.pendingUserConfirmation=[e],E(p,{pendingUserConfirmation:v.pendingUserConfirmation})}function K(e){if(v.pendingUserConfirmation){const t=v.pendingUserConfirmation.indexOf(e);t>=0&&(v.pendingUserConfirmation.splice(t,1),0===v.pendingUserConfirmation.length&&(v.pendingUserConfirmation=void 0),E(p,{pendingUserConfirmation:v.pendingUserConfirmation}))}}const Q={onTxRequested:e=>{l.debug("onTxRequested",{txRequest:e}),X("transaction")},onTxCancelled:e=>{l.debug("onTxCancelled",{txRequest:e}),K("transaction")},onTxSent:({hash:e,from:t,gasLimit:o,nonce:n,gasPrice:r,data:i,value:a,chainId:c,to:s,submissionBlockTime:d})=>{if(l.debug("onTxSent",{hash:e,from:t,gasLimit:o,nonce:n,gasPrice:r,data:i,value:a,chainId:c,to:s}),e){!function(e,t,o){Ie(e,t,o,!0)}(t,c,{hash:e,from:t,acknowledged:!1,status:"pending",to:s,nonce:n,gasLimit:o.toString(),gasPrice:r.toString(),data:i,value:a.toString(),submissionBlockTime:d,confirmations:0,finalized:!1})}K("transaction")},onSignatureRequested:e=>{l.debug("onSignatureRequested",{sigRequest:e}),X("signature")},onSignatureCancelled:e=>{l.debug("onSignatureCancelled",{sigRequest:e}),K("signature")},onSignatureReceived:e=>{l.debug("onSignatureReceived",{sigResponse:e}),K("signature")},onContractTxRequested:({from:e,contractName:t,method:o,overrides:n,metadata:r})=>{l.debug("onContractTxRequest",{from:e,contractName:t,method:o,overrides:n,metadata:r})},onContractTxCancelled:({from:e,contractName:t,method:o,overrides:n,metadata:r})=>{l.debug("onContractTxCancelled",{from:e,contractName:t,method:o,overrides:n,metadata:r})},onContractTxSent:({hash:e,from:t,contractName:o,method:n,args:r,eventsABI:i,overrides:a,metadata:c,to:s,chainId:d})=>{var u,g,f;if(l.debug("onContractTxSent",{hash:e,from:t,contractName:o,method:n,args:r,eventsABI:i,overrides:a,metadata:c,to:s}),e){let l;a&&a.nonce&&(l=parseInt(a.nonce.toString())),pe(t,d,{hash:e,from:t,acknowledged:!1,cancelled:!1,cancelationAcknowledged:!1,contractName:o,method:n,args:r,eventsABI:i,metadata:c,to:s,nonce:l,gasLimit:null===(u=null==a?void 0:a.gasLimit)||void 0===u?void 0:u.toString(),gasPrice:null===(g=null==a?void 0:a.gasPrice)||void 0===g?void 0:g.toString(),value:null===(f=null==a?void 0:a.value)||void 0===f?void 0:f.toString()},!1)}}};function Z(e){try{localStorage.setItem(S,e)}catch(e){}}function ee(e,t){return __awaiter(this,void 0,void 0,function*(){const o=oe(t);let n;if("Idle"===h.state){let e;E(C,{connecting:!0});try{e=(yield o.getNetwork()).chainId}catch(e){const t={code:d.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw E(C,{error:t,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(t.message)}n=String(e),E(C,{chainId:n,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"})}else n=h.chainId;if(!n){const e={code:d.CHAIN_ID_NOT_SET,message:"chainId is not set even though chain is connected"};throw E(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}Ce(e,n),l.log("LOAD_CHAIN from setupChain"),yield te(n,e,t)})}function te(e,t,n){return __awaiter(this,void 0,void 0,function*(){const r=oe(n);E(C,{loadingData:!0});const i={},a={};let s={},u=L;if("function"==typeof u&&(u=yield u(e)),u){if(u.chainId){const t=u;if(e!==t.chainId&&e!=(Y(g=t.chainId)?""+parseInt(g.slice(2)):g)){const o={code:d.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${t.chainId} , not available for ${e}`};throw E(C,{error:o,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(o.message)}s=t.contracts}else{const t=u,o=t[e]||t[function(e){return Y(e)?e:"0x"+parseInt(e).toString(16)}(e)];if(!o){const t={code:d.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${e}`};throw E(C,{error:t,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(t.message)}s=o.contracts}for(const n of Object.keys(s)){const d=s[n];d.abi&&(l.log({contractName:n}),i[n]=c.proxyContract(new o.Contract(d.address,d.abi,r.getSigner(t)),n,e,Q)),a[n]=d.address}}var g;if(E(C,{state:"Ready",loadingData:!1,connecting:!1,chainId:e,addresses:a,contracts:i}),"Ready"===v.state&&(l.log("READY"),D&&void 0===m.executionError&&!m.executing)){l.log(" => executing...");const e=D;if($){let t;try{l.log("executing after chain Setup"),t=$(i)}catch(e){return void E(x,{executionError:e,executing:!1})}"then"in t?(E(x,{error:void 0,executionError:void 0,executing:!0}),t.then(()=>{E(x,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),e(i),j=void 0,U=void 0,D=void 0}).catch(e=>{E(x,{executionError:e,executing:!1})})):(E(x,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i),j=void 0,U=void 0,D=void 0)}else E(x,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i),j=void 0,U=void 0,D=void 0}})}function oe(e){if(void 0===P||void 0===N){const e={code:d.CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw E(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}return e&&(P=c.proxyWeb3Provider(new n.Web3Provider(N),Q)),P}function ne(e){const t=oe(!1),o=h.contracts;if(o)for(const n of Object.keys(o))o[n]=o[n].connect(e?t.getSigner(e):t)}function re(e,t){return __awaiter(this,void 0,void 0,function*(){!v.selected||"Ready"!==v.state&&"Locked"!==v.state||(yield ge());let o,r=e;if(!r)if(0===A.length)r="builtin";else{if(1!==A.length){const e=`No Wallet Type Specified, choose from ${v.options}`;throw new Error(e)}r=A[0]}if("builtin"==r&&"Ready"===g.state&&!g.available){throw new Error("No Builtin Wallet")}if(E(p,{address:void 0,connecting:!0,selected:e,state:"Idle",error:void 0}),P=void 0,N=void 0,"builtin"===r){T=void 0;const e=yield se();N=e,P=c.proxyWeb3Provider(new n.Web3Provider(e),Q)}else{let o;if("string"==typeof r){if(A)for(const t of A)"string"!=typeof t&&t.id===e&&(o=t)}else e=(o=r).id;if(!o){const t=`no module found ${e}`;throw E(p,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}try{"load"in o&&(E(p,{loadingModule:!0}),o=yield o.load(),E(p,{loadingModule:!1})),l.log("setting up module");const{web3Provider:e}=yield o.setup(t);l.log("module setup"),N=e,P=c.proxyWeb3Provider(new n.Web3Provider(N),Q),T=o}catch(e){throw"USER_CANCELED"===e.message?E(p,{connecting:!1,selected:void 0,loadingModule:!1}):E(p,{error:{code:d.MODULE_ERROR,message:e.message},selected:void 0,connecting:!1,loadingModule:!1}),e}}if(!P){const t=`no provider found for wallet type ${e}`;throw E(p,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}N&&(l.debug("listenning for connection..."),N.on&&N.on("connect",z),N.on&&N.on("disconnect",V));try{"builtin"===e&&"Metamask"===g.vendor?o=yield a.timeout(2e3,P.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'}):(l.log("fetching accounts..."),o=yield P.listAccounts(),l.log(`accounts: ${o}`))}catch(e){throw E(p,{error:e,selected:void 0,connecting:!1}),e}Z(e);const i=o&&o[0];i?(E(p,{address:i,state:"Ready",connecting:void 0}),F(),l.log("SETUP_CHAIN from select"),yield ee(i,!1)):(F(),E(p,{address:void 0,state:"Locked",connecting:void 0}))})}let ie,ae,ce;function se(){return ie||(ie=new Promise((e,t)=>__awaiter(this,void 0,void 0,function*(){if("Ready"===g.state)return e();E(y,{probing:!0});try{const e=yield i.fetchEthereum();e?(e.autoRefreshOnNetworkChange=!1,R=e,E(y,{state:"Ready",vendor:i.getVendor(e),available:!0,probing:!1})):E(y,{state:"Ready",vendor:void 0,available:!1,probing:!1})}catch(e){return E(y,{error:e.message||e,vendor:void 0,available:void 0,probing:!1}),t(e)}e(R)})))}function de(e,t){return __awaiter(this,void 0,void 0,function*(){return yield re(e,t),"Locked"!==v.state||fe()})}function le(e){return()=>{E(e,{error:void 0})}}function ue(e){N&&q&&(l.log("STOP LISTENNING"),l.debug("stop listenning for changes..."),N.removeListener&&N.removeListener("chainChanged",H),N.removeListener&&N.removeListener("accountsChanged",B),q=!1),N&&(l.debug("stop listenning for connection..."),N.removeListener&&N.removeListener("connect",z),N.removeListener&&N.removeListener("disconnect",V)),E(p,{state:"Idle",address:void 0,connecting:!1,unlocking:void 0,selected:void 0,error:void 0}),ye(),E(k,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),E(C,{contracts:void 0,addresses:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),e||(E(x,{error:void 0,executing:!1,executionError:void 0,inProgress:!1}),$=void 0,U=void 0,D=void 0,j=void 0),Z("")}function ge(e){if(v.disconnecting)throw new Error("already disconnecting");const t=e&&e.logout,o=e&&e.wait,n=e&&e.keepFlow;return new Promise((e,r)=>{if(T)if(t){let t;try{t=T.logout()}catch(e){r(e)}o&&t&&"then"in t?(E(p,{disconnecting:!0}),t.then(()=>{T&&T.disconnect(),T=void 0,ue(n),E(p,{disconnecting:!1}),e()}).catch(e=>{E(p,{disconnecting:!1,error:e}),r(e)})):(T.disconnect(),T=void 0,ue(n),e())}else T.disconnect(),T=void 0,ue(n),e();else ue(n),e()})}function fe(){if(ae)return ae;let e=!1;const t=new Promise((t,o)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===v.state){let o;E(p,{unlocking:!0});try{o=(o=yield null==P?void 0:P.send("eth_requestAccounts",[]))||[]}catch(e){o=[]}if(!(o.length>0))return E(p,{unlocking:!1}),ae=void 0,e=!0,t(!1);{const e=o[0];E(p,{address:e,state:"Ready",unlocking:void 0}),l.log("SETUP_CHAIN from unlock"),yield ee(e,!0)}return ae=void 0,e=!0,t(!0)}return e=!0,o(new Error("Not Locked"))}));return e||(ae=t),t}function he(){if(l.log("RETRYING..."),"Ready"===h.state&&"Ready"===v.state){if(h.contracts){const e=h.contracts;if($){let t;try{l.log("EXECUTING RETRY"),t=$(e)}catch(e){return E(x,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in t)return E(x,{executing:!0}),t.then(()=>($=void 0,E(x,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D&&D(e))).catch(e=>(E(x,{executionError:e,executing:!1}),Promise.reject(e)))}return D&&D(e),Promise.resolve()}return Promise.reject("contracts not set")}return"Locked"===v.state?O.flow&&O.flow.autoUnlock&&fe().catch(e=>{E(x,{error:e})}):"Idle"===v.state&&1===v.options.length&&O.flow&&O.flow.autoSelect&&de(v.options[0]).catch(e=>{E(x,{error:e})}),j?j.then(()=>void 0):Promise.resolve()}function ve(e,t){return m.inProgress&&we(),be(void 0,e,t)}function me(e){return be(e)}function be(e,t,o){if(m.inProgress)throw new Error("flow in progress");if("Ready"===h.state&&"Ready"===v.state&&(!t||t===v.selected)){if(U=void 0,D=void 0,j=void 0,h.contracts){const t=h.contracts;if(e){let o;try{l.log("EXECUTING DIRECT"),o=e(t)}catch(e){return E(x,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in o)return $=e,E(x,{inProgress:!0,error:void 0,executing:!0}),o.then(()=>($=void 0,E(x,{inProgress:!1,error:void 0,executionError:void 0}),t)).catch(e=>(E(x,{executionError:e,executing:!1}),Promise.reject(e)))}return Promise.resolve(t)}return Promise.reject("contracts not set")}return j||($=e,E(x,{inProgress:!0,executing:!1,executionError:void 0,error:void 0}),j=new Promise((e,t)=>{D=e,U=t}),t&&t!==v.selected?v.selected?ge({keepFlow:!0}).catch(e=>{E(x,{error:e})}).then(()=>{de(t,o).catch(e=>{E(x,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),ge()})}):de(t,o).catch(e=>{E(x,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),ge()}):"Locked"===v.state?O.flow&&O.flow.autoUnlock&&fe().catch(e=>{E(x,{error:e})}):"Idle"===v.state&&1===v.options.length&&O.flow&&O.flow.autoSelect&&de(v.options[0]).catch(e=>{E(x,{error:e})}),j)}function we(){U&&U({code:1,message:"Cancel"}),j=void 0,U=void 0,D=void 0,$=void 0,E(x,{inProgress:!1,error:void 0,executionError:void 0,executing:!1})}function pe(e,t,o,n){if(!w.find(e=>e.hash===o.hash))throw new Error("cannot update non-existing Transaction record");Ie(e,t,o,n)}function Ie(e,t,o,n){if(v.address&&v.address.toLowerCase()===e.toLowerCase()&&h.chainId&&t===h.chainId){l.log("TransactionRecord",o);const r=w.find(e=>e.hash===o.hash);if(r){const e=r,t=o;for(const o of Object.keys(t))(n||!n&&void 0===e[o])&&(e[o]=t[o])}else w.push(o);try{localStorage.setItem(_+`_${e.toLowerCase()}_${t}`,JSON.stringify(w))}catch(e){}I.set(w)}else try{const r=_+`_${e.toLowerCase()}_${t}`,i=localStorage.getItem(r)||"[]",a=JSON.parse(i),c=a.find(e=>e.hash===o.hash);if(c){const e=c,t=o;for(const r of Object.keys(o))(!n&&void 0===e[r]||n&&void 0!==t[r])&&(e[r]=t[r])}else a.push(o);localStorage.setItem(r,JSON.stringify(a))}catch(e){}}function ye(){w.splice(0,w.length),I.set(w),ke()}function Ce(e,t){try{const o=localStorage.getItem(_+`_${e.toLowerCase()}_${t}`);let n=[];o&&(n=JSON.parse(o)),w.splice(0,w.length,...n),I.set(w),function(e,t){ke(),_e(e,t),ce=setInterval(()=>_e(e,t),1e3*O.transactions.pollingPeriod)}(e,t)}catch(e){}}function ke(){ce&&(clearInterval(ce),ce=void 0)}let xe=!1;function _e(e,t){return __awaiter(this,void 0,void 0,function*(){if(xe)return;xe=!0;const o=O.transactions.finality,n=w.concat();for(const r of n){if(!P)break;if(v.address!==e||h.chainId!==t)break;if(!ce)break;let n;try{n=yield P.getBlock("latest")}catch(e){l.error(e);break}if(r.finalized)continue;if(!P)break;if(v.address!==e||h.chainId!==t)break;if(!ce)break;let i=0;if(n.number>o)try{i=yield P.getTransactionCount(e,n.number-o)}catch(e){l.error(e);break}if(!P)break;if(v.address!==e||h.chainId!==t)break;if(!ce)break;let a,c=0;try{c=yield P.getTransactionCount(e)}catch(e){l.error(e);break}if(!P)break;if(v.address!==e||h.chainId!==t)break;if(!ce)break;try{a=yield P.getTransactionReceipt(r.hash)}catch(e){l.error(e);continue}if(v.address!==e||h.chainId!==t)break;if(!ce)break;const s={hash:r.hash};let d=!1;if(a&&a.blockHash){if(void 0!==a.status){const e=1===a.status;s.status=e?"success":"failure",e&&(s.events=[])}else s.status="unknown";s.blockHash=a.blockHash,s.confirmations=a.confirmations,a.confirmations>=o&&(s.finalized=!0,(r.acknowledged||O.transactions.autoDelete)&&(d=!0))}else i>r.nonce?(s.status="cancelled",s.finalized=!0,(r.acknowledged||O.transactions.autoDelete)&&(d=!0)):c>r.nonce&&(s.status="cancelled"),r.blockHash&&(s.status="pending",s.blockHash=void 0,s.blockNumber=void 0,s.confirmations=0,s.events=void 0);if(r.status!==s.status&&(s.acknowledged=!1),d)Se(r.hash);else{s.lastCheck=n.timestamp;try{pe(e,t,s,!0)}catch(e){l.error(e)}}}xe=!1})}function Se(e){if(l.log(`deleting  ${e}`),v.address&&h.chainId){const t=w.findIndex(t=>t.hash===e);w.splice(t,1);try{localStorage.setItem(_+`_${v.address.toLowerCase()}_${h.chainId}`,JSON.stringify(w))}catch(e){}I.set(w)}}t.default=(e=>{(O={builtin:{autoProbe:!!e.builtin&&e.builtin.autoProbe},flow:{autoSelect:!(!e.flow||!e.flow.autoSelect),autoUnlock:!(!e.flow||!e.flow.autoUnlock)},debug:e.debug||!1,chainConfigs:e.chainConfigs,options:e.options||[],autoSelectPrevious:!!e.autoSelectPrevious,localStoragePrefix:e.localStoragePrefix||"",transactions:{autoDelete:!0,finality:e.transactions&&e.transactions.finality||12,pollingPeriod:e.transactions&&e.transactions.pollingPeriod||10}}).options&&0!==O.options.length||(O.options=["builtin"]),S=O.localStoragePrefix+S,_=O.localStoragePrefix+_;const{debug:t,chainConfigs:o,builtin:n}=O;if(L=o,t&&"undefined"!=typeof window&&(window.$wallet=v,window.$transactions=w),A=O.options,E(p,{state:"Idle",options:A.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),E(y,{state:"Idle"}),E(C,{state:"Idle"}),E(k,{state:"Idle"}),u){if(e.autoSelectPrevious){const e=function(){try{return localStorage.getItem(S)}catch(e){return null}}();e&&""!==e&&re(e)}n.autoProbe&&se()}return{transactions:{subscribe:I.subscribe,acknowledge(e,t){if(v.address&&h.chainId){const o=w.find(t=>t.hash===e);if(o)if(o.finalized)Se(e);else{o.lastAcknowledgment=t,o.acknowledged=!0;try{localStorage.setItem(_+`_${v.address.toLowerCase()}_${h.chainId}`,JSON.stringify(w))}catch(e){}I.set(w)}}}},balance:{subscribe:k.subscribe,acknowledgeError:le(k)},chain:{subscribe:C.subscribe,acknowledgeError:le(C)},builtin:{subscribe:y.subscribe,acknowledgeError:le(y),probe:se},wallet:{subscribe:p.subscribe,connect:de,unlock:fe,acknowledgeError:le(p),disconnect:ge,get options(){return v.options},get address(){return v.address},get provider(){return P},get web3Provider(){return N},get chain(){return h},get contracts(){return h.contracts},get balance(){return f.amount}},flow:{subscribe:x.subscribe,execute:me,retry:he,cancel:we,connect:ve}}})});