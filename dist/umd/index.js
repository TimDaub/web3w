var __awaiter=this&&this.__awaiter||function(e,o,t,n){return new(t||(t=Promise))(function(r,i){function c(e){try{d(n.next(e))}catch(e){i(e)}}function s(e){try{d(n.throw(e))}catch(e){i(e)}}function d(e){var o;e.done?r(e.value):(o=e.value,o instanceof t?o:new t(function(e){e(o)})).then(c,s)}d((n=n.apply(e,o||[])).next())})};!function(e){if("object"==typeof module&&"object"==typeof module.exports){var o=e(require,exports);void 0!==o&&(module.exports=o)}else"function"==typeof define&&define.amd&&define(["require","exports","@ethersproject/contracts","@ethersproject/providers","./utils/store","./utils/builtin","./utils/index.js","./utils/ethers","named-logs","./errors"],e)}(function(e,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0});const t=e("@ethersproject/contracts"),n=e("@ethersproject/providers"),r=e("./utils/store"),i=e("./utils/builtin"),c=e("./utils/index.js"),s=e("./utils/ethers"),d=e("named-logs"),a=e("./errors"),u=d.logs("web3w:index"),l="undefined"!=typeof window,g={state:"Idle",probing:!1,available:void 0,error:void 0,vendor:void 0},f={state:"Idle",fetching:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},v={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},h={state:"Idle",connecting:!1,disconnecting:!1,loadingModule:!1,unlocking:!1,address:void 0,options:["builtin"],selected:void 0,pendingUserConfirmation:void 0,error:void 0},m={inProgress:!1,executing:!1,executionError:void 0,error:void 0};function b(e){const o=r.writable(e);return o.data=e,o}const p=[],w=b(h),y=b(p),I=b(g),x=b(v),C=b(f),E=b(m);function _(e,o){for(const t of Object.keys(o)){const n=o,r=e;if(r.data[t]&&"object"==typeof n[t])for(const e of Object.keys(n[t]))r.data[t][e]=n[t][e];else r.data[t]=n[t]}try{u.debug(JSON.stringify(e.data,null,"  "))}catch(o){u.error(o,e.data)}e.set(e.data)}let P,N,S,k,R,A,L,T,D,j,O,U=!1;function q(e){return __awaiter(this,void 0,void 0,function*(){if("0xNaN"===e){if(u.warn("onChainChanged bug (return 0xNaN), metamask bug?"),!N)throw new Error("no web3Provider to get chainId");e=yield W(N,"eth_chainId")}const o=parseInt(e.slice(2),16).toString();u.debug("onChainChanged",{chainId:e,chainIdAsDecimal:o}),_(x,{contracts:void 0,addresses:void 0,state:"Connected",chainId:o,notSupported:void 0}),h.address&&(u.log("LOAD_CHAIN from chainChanged"),yield ee(o,h.address,!0))})}function M(e){return e[0]!==h.address}function H(e){return __awaiter(this,void 0,void 0,function*(){if(!M(e))return void u.debug("false account changed",e);u.debug("onAccountsChanged",{accounts:e});const o=e[0];if(o)if(_(w,{address:o,state:"Ready"}),"Connected"===v.state){if(!v.chainId)throw new Error("no chainId while connected");u.log("LOAD_CHAIN from accountsChanged"),yield ee(v.chainId,o,!1)}else te(o);else _(w,{address:o,state:"Locked"}),te(o)})}function W(e,o,t){var n;if(e.request)return e.request({method:o,params:t});const r=null===(n=e.sendAsync)||void 0===n?void 0:n.bind(e);if(r)return new Promise((e,n)=>{r({method:o,params:t},(o,t)=>{o?n(o):t.error?n(t.error):e(t.result)})});throw new Error("provider not supported")}function $(e){return new Promise(o=>{setTimeout(o,e)})}function G(e,o){return __awaiter(this,void 0,void 0,function*(){for(;U;){let t=[];try{t=yield W(e,"eth_accounts")}catch(e){}if(u.debug({accounts:t}),U&&M(t))try{o(t)}catch(e){u.error(e)}yield $(3e3)}})}function F(){N&&!U&&(u.log("LISTENNING"),N.on?(N.on("chainChanged",q),N.on("accountsChanged",H),G(N,H)):(!function(e,o){__awaiter(this,void 0,void 0,function*(){for(;U;){const t=yield W(e,"eth_chainId"),n=parseInt(t.slice(2),16).toString();if(U&&v.chainId!==n)try{o(t)}catch(e){u.error(e)}yield $(3e3)}})}(N,q),G(N,H)),U=!0)}function V({chainId:e}){const o=parseInt(e.slice(2),16).toString();u.debug("onConnect",{chainId:e,chainIdAsDecimal:o})}function B(e){u.debug("onDisconnect",{error:e})}function Y(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function X(e){h.pendingUserConfirmation?h.pendingUserConfirmation.push(e):h.pendingUserConfirmation=[e],_(w,{pendingUserConfirmation:h.pendingUserConfirmation})}function J(e){if(h.pendingUserConfirmation){const o=h.pendingUserConfirmation.indexOf(e);o>=0&&(h.pendingUserConfirmation.splice(o,1),0===h.pendingUserConfirmation.length&&(h.pendingUserConfirmation=void 0),_(w,{pendingUserConfirmation:h.pendingUserConfirmation}))}}const z={onTxRequested:e=>{u.debug("onTxRequested",{transaction:e}),X("transaction")},onTxCancelled:e=>{u.debug("onTxCancelled",{transaction:e}),J("transaction")},onTxSent:e=>{u.debug("onTxSent",{transaction:e}),J("transaction")},onSignatureRequested:e=>{u.debug("onSignatureRequested",{message:e}),X("signature")},onSignatureCancelled:e=>{u.debug("onSignatureCancelled",{message:e}),J("signature")},onSignatureReceived:e=>{u.debug("onSignatureReceived",{signature:e}),J("signature")},onContractTxRequested:({name:e,method:o,overrides:t,outcome:n})=>{u.debug("onContractTxRequest",{name:e,method:o,overrides:t,outcome:n})},onContractTxCancelled:({name:e,method:o,overrides:t,outcome:n})=>{u.debug("onContractTxCancelled",{name:e,method:o,overrides:t,outcome:n})},onContractTxSent:({hash:e,name:o,method:t,overrides:n,outcome:r})=>{u.debug("onContractTxSent",{hash:e,name:o,method:t,overrides:n,outcome:r}),e&&function(e){p.push(e),y.set(p)}({hash:e,name:o,method:t,overrides:n,outcome:r})}},K="_web3w_previous_wallet_type";function Q(e){localStorage.setItem(K,e)}function Z(e,o){return __awaiter(this,void 0,void 0,function*(){const t=oe(o);let n;if("Idle"===v.state){let e;_(x,{connecting:!0});try{e=(yield t.getNetwork()).chainId}catch(e){const o={code:a.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw _(x,{error:o,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(o.message)}n=String(e),_(x,{chainId:n,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"})}else n=v.chainId;if(!n){const e={code:a.CHAIN_ID_NOT_SET,message:"chainId is not set even though chain is connected"};throw _(x,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}u.log("LOAD_CHAIN from setupChain"),yield ee(n,e,o)})}function ee(e,o,n){return __awaiter(this,void 0,void 0,function*(){const r=oe(n);_(x,{loadingData:!0});const i={},c={};let d={},l=k;if("function"==typeof l&&(l=yield l(e)),l){if(l.chainId){const o=l;if(e!==o.chainId&&e!=(Y(g=o.chainId)?""+parseInt(g.slice(2)):g)){const t={code:a.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${o.chainId} , not available for ${e}`};throw _(x,{error:t,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(t.message)}d=o.contracts}else{const o=l,t=o[e]||o[function(e){return Y(e)?e:"0x"+parseInt(e).toString(16)}(e)];if(!t){const o={code:a.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${e}`};throw _(x,{error:o,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(o.message)}d=t.contracts}for(const e of Object.keys(d)){const n=d[e];n.abi&&(i[e]=s.proxyContract(new t.Contract(n.address,n.abi,r.getSigner(o)),e,z)),c[e]=n.address}}var g;if(_(x,{state:"Ready",loadingData:!1,connecting:!1,chainId:e,addresses:c,contracts:i}),"Ready"===h.state&&(u.log("READY"),D&&void 0===m.executionError&&!m.executing)){u.log(" => executing...");const e=D;if(O){let o;try{u.log("executing after chain Setup"),o=O(i)}catch(e){return void _(E,{executionError:e,executing:!1})}"then"in o?(_(E,{error:void 0,executionError:void 0,executing:!0}),o.then(()=>{_(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),e(i),T=void 0,j=void 0,D=void 0}).catch(e=>{_(E,{executionError:e,executing:!1})})):(_(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i))}else _(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D(i)}})}function oe(e){if(void 0===P||void 0===N){const e={code:a.CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw _(x,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}return e&&(P=s.proxyWeb3Provider(new n.Web3Provider(N),z)),P}function te(e){const o=oe(!1),t=v.contracts;if(t)for(const n of Object.keys(t))t[n]=t[n].connect(e?o.getSigner(e):o)}function ne(e,o){return __awaiter(this,void 0,void 0,function*(){!h.selected||"Ready"!==h.state&&"Locked"!==h.state||(yield ue());let t,r=e;if(!r)if(0===A.length)r="builtin";else{if(1!==A.length){const e=`No Wallet Type Specified, choose from ${h.options}`;throw new Error(e)}r=A[0]}if("builtin"==r&&"Ready"===g.state&&!g.available){throw new Error("No Builtin Wallet")}if(_(w,{address:void 0,connecting:!0,selected:e,state:"Idle",error:void 0}),P=void 0,N=void 0,"builtin"===r){R=void 0;const e=yield ce();N=e,P=s.proxyWeb3Provider(new n.Web3Provider(e),z)}else{let t;if("string"==typeof r){if(A)for(const o of A)"string"!=typeof o&&o.id===e&&(t=o)}else e=(t=r).id;if(!t){const o=`no module found ${e}`;throw _(w,{error:{message:o,code:1},selected:void 0,connecting:!1}),new Error(o)}try{"load"in t&&(_(w,{loadingModule:!0}),t=yield t.load(),_(w,{loadingModule:!1}));const{web3Provider:e}=yield t.setup(o);N=e,P=s.proxyWeb3Provider(new n.Web3Provider(N),z),R=t}catch(e){throw"USER_CANCELED"===e.message?_(w,{connecting:!1,selected:void 0,loadingModule:!1}):_(w,{error:{code:a.MODULE_ERROR,message:e.message},selected:void 0,connecting:!1,loadingModule:!1}),e}}if(!P){const o=`no provider found for wallet type ${e}`;throw _(w,{error:{message:o,code:1},selected:void 0,connecting:!1}),new Error(o)}N&&(u.debug("listenning for connection..."),N.on&&N.on("connect",V),N.on&&N.on("disconnect",B));try{t="builtin"===e&&"Metamask"===g.vendor?yield c.timeout(2e3,P.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'}):yield P.listAccounts()}catch(e){throw _(w,{error:e,selected:void 0,connecting:!1}),e}Q(e);const i=t&&t[0];i?(_(w,{address:i,state:"Ready",connecting:void 0}),F(),u.log("SETUP_CHAIN from select"),yield Z(i,!1)):(F(),_(w,{address:void 0,state:"Locked",connecting:void 0}))})}let re,ie;function ce(){return re||(re=new Promise((e,o)=>__awaiter(this,void 0,void 0,function*(){if("Ready"===g.state)return e();_(I,{probing:!0});try{const e=yield i.fetchEthereum();e?(e.autoRefreshOnNetworkChange=!1,S=e,_(I,{state:"Ready",vendor:i.getVendor(e),available:!0,probing:!1})):_(I,{state:"Ready",vendor:void 0,available:!1,probing:!1})}catch(e){return _(I,{error:e.message||e,vendor:void 0,available:void 0,probing:!1}),o(e)}e(S)})))}function se(e,o){return __awaiter(this,void 0,void 0,function*(){return yield ne(e,o),"Locked"!==h.state||le()})}function de(e){return()=>{_(e,{error:void 0})}}function ae(){N&&U&&(u.log("STOP LISTENNING"),u.debug("stop listenning for changes..."),N.removeListener&&N.removeListener("chainChanged",q),N.removeListener&&N.removeListener("accountsChanged",H),U=!1),N&&(u.debug("stop listenning for connection..."),N.removeListener&&N.removeListener("connect",V),N.removeListener&&N.removeListener("disconnect",B)),_(w,{state:"Idle",address:void 0,connecting:!1,unlocking:void 0,selected:void 0,error:void 0}),_(C,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),_(x,{contracts:void 0,addresses:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),_(E,{error:void 0,executing:!1,executionError:void 0,inProgress:!1}),O=void 0,j=void 0,D=void 0,T=void 0,Q("")}function ue(e){if(h.disconnecting)throw new Error("already disconnecting");const o=e&&e.logout,t=e&&e.wait;return new Promise((e,n)=>{if(R)if(o){let o;try{o=R.logout()}catch(e){n(e)}t&&o&&"then"in o?(_(w,{disconnecting:!0}),o.then(()=>{R&&R.disconnect(),R=void 0,ae(),_(w,{disconnecting:!1}),e()}).catch(e=>{_(w,{disconnecting:!1,error:e}),n(e)})):(R.disconnect(),R=void 0,ae(),e())}else R.disconnect(),R=void 0,ae(),e();else ae(),e()})}function le(){if(ie)return ie;let e=!1;const o=new Promise((o,t)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===h.state){let t;_(w,{unlocking:!0});try{t=(t=yield null==P?void 0:P.send("eth_requestAccounts",[]))||[]}catch(e){t=[]}if(!(t.length>0))return _(w,{unlocking:!1}),ie=void 0,e=!0,o(!1);{const e=t[0];_(w,{address:e,state:"Ready",unlocking:void 0}),u.log("SETUP_CHAIN from unlock"),yield Z(e,!0)}return ie=void 0,e=!0,o(!0)}return e=!0,t(new Error("Not Locked"))}));return e||(ie=o),o}function ge(){if(u.log("RETRYING..."),"Ready"===v.state&&"Ready"===h.state){if(v.contracts){const e=v.contracts;if(O){let o;try{u.log("EXECUTING RETRY"),o=O(e)}catch(e){return _(E,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in o)return _(E,{executing:!0}),o.then(()=>(O=void 0,_(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),D&&D(e))).catch(e=>(_(E,{executionError:e,executing:!1}),Promise.reject(e)))}return D&&D(e),Promise.resolve()}return Promise.reject("contracts not set")}return"Locked"===h.state?L.flow&&L.flow.autoUnlock&&le().catch(e=>{_(E,{error:e})}):"Idle"===h.state&&1===h.options.length&&L.flow&&L.flow.autoSelect&&se(h.options[0]).catch(e=>{_(E,{error:e})}),T?T.then(()=>void 0):Promise.resolve()}function fe(){return m.inProgress&&he(),ve()}function ve(e){if(m.inProgress)throw new Error("flow in progress");if("Ready"===v.state&&"Ready"===h.state){if(j=void 0,D=void 0,T=void 0,v.contracts){const o=v.contracts;if(e){let t;try{u.log("EXECUTING DIRECT"),t=e(o)}catch(e){return _(E,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in t)return O=e,_(E,{inProgress:!0,error:void 0,executing:!0}),t.then(()=>(O=void 0,_(E,{inProgress:!1,error:void 0,executionError:void 0}),o)).catch(e=>(_(E,{executionError:e,executing:!1}),Promise.reject(e)))}return Promise.resolve(o)}return Promise.reject("contracts not set")}return T||(O=e,_(E,{inProgress:!0,executing:!1,executionError:void 0,error:void 0}),T=new Promise((e,o)=>{D=e,j=o}),"Locked"===h.state?L.flow&&L.flow.autoUnlock&&le().catch(e=>{_(E,{error:e})}):"Idle"===h.state&&1===h.options.length&&L.flow&&L.flow.autoSelect&&se(h.options[0]).catch(e=>{_(E,{error:e})}),T)}function he(){j&&j({code:1,message:"Cancel"}),T=void 0,j=void 0,D=void 0,O=void 0,_(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1})}o.default=(e=>{(e=Object.assign({},e||{})).options&&0!==e.options.length||(e.options=["builtin"]),e.builtin=e.builtin||{autoProbe:!1},e.flow=e.flow||{autoSelect:!1,autoUnlock:!1};const{debug:o,chainConfigs:t,builtin:n}=e;if(L=e,k=t,o&&"undefined"!=typeof window&&(window.$wallet=h,window.$transactions=p),A=e.options,_(w,{state:"Idle",options:A.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),_(I,{state:"Idle"}),_(x,{state:"Idle"}),_(C,{state:"Idle"}),l){if(e.autoSelectPrevious){const e=localStorage.getItem(K);e&&""!==e&&ne(e)}n.autoProbe&&ce()}return{transactions:{subscribe:y.subscribe},balance:{subscribe:C.subscribe,acknowledgeError:de(C)},chain:{subscribe:x.subscribe,acknowledgeError:de(x)},builtin:{subscribe:I.subscribe,acknowledgeError:de(I),probe:ce},wallet:{subscribe:w.subscribe,connect:se,unlock:le,acknowledgeError:de(w),disconnect:ue,get options(){return h.options},get address(){return h.address},get provider(){return P},get web3Provider(){return N},get chain(){return v},get contracts(){return v.contracts},get balance(){return f.amount}},flow:{subscribe:E.subscribe,execute:ve,retry:ge,cancel:he,connect:fe}}})});