var __awaiter=this&&this.__awaiter||function(e,t,o,n){return new(o||(o=Promise))(function(r,i){function a(e){try{c(n.next(e))}catch(e){i(e)}}function s(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o(function(e){e(t)})).then(a,s)}c((n=n.apply(e,t||[])).next())})};!function(e){if("object"==typeof module&&"object"==typeof module.exports){var t=e(require,exports);void 0!==t&&(module.exports=t)}else"function"==typeof define&&define.amd&&define(["require","exports","@ethersproject/contracts","@ethersproject/providers","@ethersproject/abi","./utils/store","./utils/builtin","./utils","./utils/ethers","named-logs","./errors"],e)}(function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=e("@ethersproject/contracts"),n=e("@ethersproject/providers"),r=e("@ethersproject/abi"),i=e("./utils/store"),a=e("./utils/builtin"),s=e("./utils"),c=e("./utils/ethers"),d=e("named-logs"),l=e("./errors"),u=d.logs("web3w:index"),g="undefined"!=typeof window,f={state:"Idle",probing:!1,available:void 0,error:void 0,vendor:void 0},h={state:"Idle",fetching:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},v={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},m={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},b={state:"Idle",connecting:!1,disconnecting:!1,loadingModule:!1,unlocking:!1,address:void 0,options:["builtin"],selected:void 0,pendingUserConfirmation:void 0,error:void 0},w={inProgress:!1,executing:!1,executionError:void 0,error:void 0};function p(e){const t=i.writable(e);return t.data=e,t}const y=[],I=p(b),C=p(y),k=p(f),x=p(v),_=p(m),S=p(h),E=p(w);let P="_web3w_transactions",N="_web3w_previous_wallet_type";function R(e,t){for(const o of Object.keys(t)){const n=t,r=e;if(r.data[o]&&"object"==typeof n[o])for(const e of Object.keys(n[o]))r.data[o][e]=n[o][e];else r.data[o]=n[o]}try{u.debug(JSON.stringify(e.data,null,"  "))}catch(t){u.error(t,e.data)}e.set(e.data)}let L,A,O,D,T,j,U,$,q,H,M,B=!1;function J(e){return __awaiter(this,void 0,void 0,function*(){if("0xNaN"===e){if(u.warn("onChainChanged bug (return 0xNaN), metamask bug?"),!A)throw new Error("no web3Provider to get chainId");e=yield G(A,"eth_chainId")}const t=parseInt(e.slice(2),16).toString();u.debug("onChainChanged",{chainId:e,chainIdAsDecimal:t}),R(x,{contracts:void 0,addresses:void 0,state:"Connected",chainId:t,notSupported:void 0}),b.address&&(Se(b.address,t),u.log("LOAD_CHAIN from chainChanged"),yield ie(t,b.address,!0))})}function F(e){return e[0]!==b.address}function W(e){return __awaiter(this,void 0,void 0,function*(){if(!F(e))return void u.debug("false account changed",e);u.debug("onAccountsChanged",{accounts:e});const t=e[0];if(t)if(R(I,{address:t,state:"Ready"}),v.chainId&&Se(t,v.chainId),"Connected"===v.state){if(!v.chainId)throw new Error("no chainId while connected");u.log("LOAD_CHAIN from accountsChanged"),yield ie(v.chainId,t,!1)}else se(t);else _e(),R(I,{address:t,state:"Locked"}),se(t)})}function G(e,t,o){var n;if(e.request)return e.request({method:t,params:o});const r=null===(n=e.sendAsync)||void 0===n?void 0:n.bind(e);if(r)return new Promise((e,n)=>{r({method:t,params:o},(t,o)=>{t?n(t):o.error?n(o.error):e(o.result)})});throw new Error("provider not supported")}function z(e){return new Promise(t=>{setTimeout(t,e)})}function V(e,t){return __awaiter(this,void 0,void 0,function*(){for(;B;){let o=[];try{o=yield G(e,"eth_accounts")}catch(e){}if(u.debug({accounts:o}),B&&F(o))try{t(o)}catch(e){u.error(e)}yield z(3e3)}})}function Y(){A&&!B&&(u.log("LISTENNING"),A.on?(A.on("chainChanged",J),A.on("accountsChanged",W),V(A,W)):(!function(e,t){__awaiter(this,void 0,void 0,function*(){for(;B;){const o=yield G(e,"eth_chainId"),n=parseInt(o.slice(2),16).toString();if(B&&v.chainId!==n)try{t(o)}catch(e){u.error(e)}yield z(3e3)}})}(A,J),V(A,W)),B=!0)}function X(e){const t=e&&e.chainId;if(t){const e=parseInt(t.slice(2),16).toString();u.debug("onConnect",{chainId:t,chainIdAsDecimal:e})}else u.warn("onConnect","no connection object passed in")}function K(e){u.debug("onDisconnect",{error:e})}function Q(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function Z(e){b.pendingUserConfirmation?b.pendingUserConfirmation.push(e):b.pendingUserConfirmation=[e],R(I,{pendingUserConfirmation:b.pendingUserConfirmation})}function ee(e){if(b.pendingUserConfirmation){const t=b.pendingUserConfirmation.indexOf(e);t>=0&&(b.pendingUserConfirmation.splice(t,1),0===b.pendingUserConfirmation.length&&(b.pendingUserConfirmation=void 0),R(I,{pendingUserConfirmation:b.pendingUserConfirmation}))}}const te={onTxRequested:e=>{u.debug("onTxRequested",{txRequest:e}),Z("transaction")},onTxCancelled:e=>{u.debug("onTxCancelled",{txRequest:e}),ee("transaction")},onTxSent:({hash:e,from:t,gasLimit:o,nonce:n,gasPrice:r,data:i,value:a,chainId:s,to:c,submissionBlockTime:d})=>{if(u.debug("onTxSent",{hash:e,from:t,gasLimit:o,nonce:n,gasPrice:r,data:i,value:a,chainId:s,to:c}),e){!function(e,t,o){xe(e,t,o,!0)}(t,s,{hash:e,from:t,acknowledged:!1,status:"pending",to:c,nonce:n,gasLimit:o.toString(),gasPrice:r.toString(),data:i,value:a.toString(),submissionBlockTime:d,confirmations:0,finalized:!1})}ee("transaction")},onSignatureRequested:e=>{u.debug("onSignatureRequested",{sigRequest:e}),Z("signature")},onSignatureCancelled:e=>{u.debug("onSignatureCancelled",{sigRequest:e}),ee("signature")},onSignatureReceived:e=>{u.debug("onSignatureReceived",{sigResponse:e}),ee("signature")},onContractTxRequested:({from:e,contractName:t,method:o,overrides:n,metadata:r})=>{u.debug("onContractTxRequest",{from:e,contractName:t,method:o,overrides:n,metadata:r})},onContractTxCancelled:({from:e,contractName:t,method:o,overrides:n,metadata:r})=>{u.debug("onContractTxCancelled",{from:e,contractName:t,method:o,overrides:n,metadata:r})},onContractTxSent:({hash:e,from:t,contractName:o,method:n,args:r,eventsABI:i,overrides:a,metadata:s,to:c,chainId:d})=>{var l,g,f;if(u.debug("onContractTxSent",{hash:e,from:t,contractName:o,method:n,args:r,eventsABI:i,overrides:a,metadata:s,to:c}),e){let u;a&&a.nonce&&(u=parseInt(a.nonce.toString())),ke(t,d,{hash:e,from:t,acknowledged:!1,contractName:o,method:n,args:r,eventsABI:i,metadata:s,to:c,nonce:u,gasLimit:null===(l=null==a?void 0:a.gasLimit)||void 0===l?void 0:l.toString(),gasPrice:null===(g=null==a?void 0:a.gasPrice)||void 0===g?void 0:g.toString(),value:null===(f=null==a?void 0:a.value)||void 0===f?void 0:f.toString()},!1)}}};function oe(e){try{localStorage.setItem(N,e)}catch(e){}}function ne(e,t){return __awaiter(this,void 0,void 0,function*(){const o=ae(t);let n;if("Idle"===v.state){let e;R(x,{connecting:!0});try{e=(yield o.getNetwork()).chainId}catch(e){const t={code:l.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw R(x,{error:t,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(t.message)}n=String(e),R(x,{chainId:n,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"})}else n=v.chainId;if(!n){const e={code:l.CHAIN_ID_NOT_SET,message:"chainId is not set even though chain is connected"};throw R(x,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}Se(e,n),u.log("LOAD_CHAIN from setupChain"),yield ie(n,e,t)})}function re(e,t){if(e.chainId){const n=e;if(t===n.chainId||t==(Q(o=n.chainId)?""+parseInt(o.slice(2)):o))return n.contracts;throw{code:l.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${n.chainId}, not available for ${t}`}}{const o=e,n=o[t]||o[function(e){return Q(e)?e:"0x"+parseInt(e).toString(16)}(t)];if(n)return n.contracts;throw{code:l.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${t}`}}var o}function ie(e,t,n){return __awaiter(this,void 0,void 0,function*(){const r=ae(n);R(x,{loadingData:!0});const i={},a={};let s=D;if("function"==typeof s&&(s=yield s(e)),s){let n;try{n=re(s,e)}catch(t){throw R(x,{error:t,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(t.message||t)}for(const s of Object.keys(n)){const d=n[s];d.abi&&(u.log({contractName:s}),i[s]=c.proxyContract(new o.Contract(d.address,d.abi,r.getSigner(t)),s,e,te)),a[s]=d.address}}if(R(x,{state:"Ready",loadingData:!1,connecting:!1,chainId:e,addresses:a,contracts:i}),"Ready"===b.state&&(u.log("READY"),q&&void 0===w.executionError&&!w.executing)){u.log(" => executing...");const e=q;if(M){let t;try{u.log("executing after chain Setup"),t=M(i)}catch(e){return void R(E,{executionError:e,executing:!1})}"then"in t?(R(E,{error:void 0,executionError:void 0,executing:!0}),t.then(()=>{R(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),e(i),$=void 0,H=void 0,q=void 0}).catch(e=>{R(E,{executionError:e,executing:!1})})):(R(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),q(i),$=void 0,H=void 0,q=void 0)}else R(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),q(i),$=void 0,H=void 0,q=void 0}})}function ae(e){if(void 0===L||void 0===A){const e={code:l.CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw R(x,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}return e&&(L=c.proxyWeb3Provider(new n.Web3Provider(A),te)),L}function se(e){const t=ae(!1),o=v.contracts;if(o)for(const n of Object.keys(o))o[n]=o[n].connect(e?t.getSigner(e):t)}function ce(e,t){return __awaiter(this,void 0,void 0,function*(){!b.selected||"Ready"!==b.state&&"Locked"!==b.state||(yield me());let o,r=e;if(!r)if(0===j.length)r="builtin";else{if(1!==j.length){const e=`No Wallet Type Specified, choose from ${b.options}`;throw new Error(e)}r=j[0]}if("builtin"==r&&"Ready"===f.state&&!f.available){throw new Error("No Builtin Wallet")}if(R(I,{address:void 0,connecting:!0,selected:e,state:"Idle",error:void 0}),L=void 0,A=void 0,"builtin"===r){T=void 0;const e=yield ge();A=e,L=c.proxyWeb3Provider(new n.Web3Provider(e),te)}else{let o;if("string"==typeof r){if(j)for(const t of j)"string"!=typeof t&&t.id===e&&(o=t)}else e=(o=r).id;if(!o){const t=`no module found ${e}`;throw R(I,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}try{"load"in o&&(R(I,{loadingModule:!0}),o=yield o.load(),R(I,{loadingModule:!1})),u.log("setting up module");const{web3Provider:e}=yield o.setup(t);u.log("module setup"),A=e,L=c.proxyWeb3Provider(new n.Web3Provider(A),te),T=o}catch(e){throw"USER_CANCELED"===e.message?R(I,{connecting:!1,selected:void 0,loadingModule:!1}):R(I,{error:{code:l.MODULE_ERROR,message:e.message},selected:void 0,connecting:!1,loadingModule:!1}),e}}if(!L){const t=`no provider found for wallet type ${e}`;throw R(I,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}A&&(u.debug("listenning for connection..."),A.on&&A.on("connect",X),A.on&&A.on("disconnect",K));try{if("builtin"===e&&"Metamask"===f.vendor)o=yield s.timeout(2e3,L.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'});else{u.log("fetching accounts...");try{o=yield L.listAccounts()}catch(e){if(4100===e.code)u.log(`4100 ${e.name}`),o=[];else{if(-32500!==e.code||"permission denied"!==e.message)throw e;"Opera"===f.vendor?u.log("permission denied (opera) crypto wallet not enabled?)"):u.log("permission denied"),o=[]}}u.log(`accounts: ${o}`)}}catch(e){throw R(I,{error:e,selected:void 0,connecting:!1}),e}oe(e);const i=o&&o[0];i?(R(I,{address:i,state:"Ready",connecting:void 0}),Y(),u.log("SETUP_CHAIN from select"),yield ne(i,!1)):(Y(),R(I,{address:void 0,state:"Locked",connecting:void 0}))})}let de,le,ue;function ge(){return de||(de=new Promise((e,t)=>__awaiter(this,void 0,void 0,function*(){if(O&&"Ready"===f.state)return e(O);R(k,{probing:!0});try{const o=yield a.fetchEthereum();o?(o.autoRefreshOnNetworkChange=!1,O=o,R(k,{state:"Ready",vendor:a.getVendor(o),available:!0,probing:!1})):R(k,{state:"Ready",vendor:void 0,available:!1,probing:!1}),e(o)}catch(e){return R(k,{error:e.message||e,vendor:void 0,available:void 0,probing:!1}),t(e)}})))}function fe(e,t){return __awaiter(this,void 0,void 0,function*(){return yield ce(e,t),"Locked"!==b.state||be()})}function he(e){return()=>{R(e,{error:void 0})}}function ve(e){A&&B&&(u.log("STOP LISTENNING"),u.debug("stop listenning for changes..."),A.removeListener&&A.removeListener("chainChanged",J),A.removeListener&&A.removeListener("accountsChanged",W),B=!1),A&&(u.debug("stop listenning for connection..."),A.removeListener&&A.removeListener("connect",X),A.removeListener&&A.removeListener("disconnect",K)),R(I,{state:"Idle",address:void 0,connecting:!1,unlocking:void 0,selected:void 0,error:void 0}),_e(),R(S,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),R(x,{contracts:void 0,addresses:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),e||(R(E,{error:void 0,executing:!1,executionError:void 0,inProgress:!1}),M=void 0,H=void 0,q=void 0,$=void 0),oe("")}function me(e){if(b.disconnecting)throw new Error("already disconnecting");const t=e&&e.logout,o=e&&e.wait,n=e&&e.keepFlow;return new Promise((e,r)=>{if(T)if(t){let t;try{t=T.logout()}catch(e){r(e)}o&&t&&"then"in t?(R(I,{disconnecting:!0}),t.then(()=>{T&&T.disconnect(),T=void 0,ve(n),R(I,{disconnecting:!1}),e()}).catch(e=>{R(I,{disconnecting:!1,error:e}),r(e)})):(T.disconnect(),T=void 0,ve(n),e())}else T.disconnect(),T=void 0,ve(n),e();else ve(n),e()})}function be(){if(le)return le;let e=!1;const t=new Promise((t,o)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===b.state){let o;R(I,{unlocking:!0});try{o=(o=yield null==L?void 0:L.send("eth_requestAccounts",[]))||[]}catch(e){o=[]}if(!(o.length>0))return R(I,{unlocking:!1}),le=void 0,e=!0,t(!1);{const e=o[0];R(I,{address:e,state:"Ready",unlocking:void 0}),u.log("SETUP_CHAIN from unlock"),yield ne(e,!0)}return le=void 0,e=!0,t(!0)}return e=!0,o(new Error("Not Locked"))}));return e||(le=t),t}function we(){if(u.log("RETRYING..."),R(E,{executionError:void 0}),"Ready"===v.state&&"Ready"===b.state){if(v.contracts){const e=v.contracts;if(M){let t;try{u.log("EXECUTING RETRY"),t=M(e)}catch(e){return R(E,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in t)return R(E,{executing:!0}),t.then(()=>(M=void 0,R(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),q&&q(e))).catch(e=>(R(E,{executionError:e,executing:!1}),Promise.reject(e)))}return q&&q(e),Promise.resolve()}return Promise.reject("contracts not set")}return"Locked"===b.state?U.flow&&U.flow.autoUnlock&&be().catch(e=>{R(E,{error:e})}):"Idle"===b.state&&1===b.options.length&&U.flow&&U.flow.autoSelect&&fe(b.options[0]).catch(e=>{R(E,{error:e})}),$?$.then(()=>void 0):Promise.resolve()}function pe(e,t){return w.inProgress&&Ce(),Ie(void 0,e,t)}function ye(e){return Ie(e)}function Ie(e,t,o){if(w.inProgress)throw new Error("flow in progress");if("Ready"===v.state&&"Ready"===b.state&&(!t||t===b.selected)){if(H=void 0,q=void 0,$=void 0,v.contracts){const t=v.contracts;if(e){let o;try{u.log("EXECUTING DIRECT"),o=e(t)}catch(e){return R(E,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in o)return M=e,R(E,{inProgress:!0,error:void 0,executing:!0}),o.then(()=>(M=void 0,R(E,{inProgress:!1,error:void 0,executionError:void 0}),t)).catch(e=>(R(E,{executionError:e,executing:!1}),Promise.reject(e)))}return Promise.resolve(t)}return Promise.reject("contracts not set")}return $||(M=e,R(E,{inProgress:!0,executing:!1,executionError:void 0,error:void 0}),$=new Promise((e,t)=>{q=e,H=t}),t&&t!==b.selected?b.selected?me({keepFlow:!0}).catch(e=>{R(E,{error:e})}).then(()=>{fe(t,o).catch(e=>{R(E,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),me()})}):fe(t,o).catch(e=>{R(E,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),me()}):"Locked"===b.state?U.flow&&U.flow.autoUnlock&&be().catch(e=>{R(E,{error:e})}):"Idle"===b.state&&1===b.options.length&&U.flow&&U.flow.autoSelect&&fe(b.options[0]).catch(e=>{R(E,{error:e})}),$)}function Ce(){H&&H({code:1,message:"Cancel"}),$=void 0,H=void 0,q=void 0,M=void 0,R(E,{inProgress:!1,error:void 0,executionError:void 0,executing:!1})}function ke(e,t,o,n){if(!y.find(e=>e.hash===o.hash))throw new Error("cannot update non-existing Transaction record");xe(e,t,o,n)}function xe(e,t,o,n){if(b.address&&b.address.toLowerCase()===e.toLowerCase()&&v.chainId&&t===v.chainId){u.log("TransactionRecord",o);const r=y.find(e=>e.hash===o.hash);if(r){const e=r,t=o;for(const o of Object.keys(t))(n||!n&&void 0===e[o])&&(e[o]=t[o])}else y.push(o);try{localStorage.setItem(P+`_${e.toLowerCase()}_${t}`,JSON.stringify(y))}catch(e){}C.set(y)}else try{const r=P+`_${e.toLowerCase()}_${t}`,i=localStorage.getItem(r)||"[]",a=JSON.parse(i),s=a.find(e=>e.hash===o.hash);if(s){const e=s,t=o;for(const r of Object.keys(o))(!n&&void 0===e[r]||n&&void 0!==t[r])&&(e[r]=t[r])}else a.push(o);localStorage.setItem(r,JSON.stringify(a))}catch(e){}}function _e(){y.splice(0,y.length),C.set(y),Ee()}function Se(e,t){try{const o=localStorage.getItem(P+`_${e.toLowerCase()}_${t}`);let n=[];o&&(n=JSON.parse(o)),y.splice(0,y.length,...n),C.set(y),function(e,t){Ee(),Ne(e,t),ue=setInterval(()=>Ne(e,t),1e3*U.transactions.pollingPeriod)}(e,t)}catch(e){}}function Ee(){ue&&(clearInterval(ue),ue=void 0)}let Pe=!1;function Ne(e,t){return __awaiter(this,void 0,void 0,function*(){if(Pe)return;Pe=!0;const o=U.transactions.finality,n=y.concat();for(const i of n){if(!L)break;if(b.address!==e||v.chainId!==t)break;if(!ue)break;let n;try{n=yield L.getBlock("latest")}catch(e){u.error(e);break}if(i.finalized)continue;if(!L)break;if(b.address!==e||v.chainId!==t)break;if(!ue)break;let a=0;if(n.number>=o)try{a=yield L.getTransactionCount(e,n.number-Math.max(1,o)+1)}catch(e){u.error(e);break}if(!L)break;if(b.address!==e||v.chainId!==t)break;if(!ue)break;let s,c=0;try{c=yield L.getTransactionCount(e)}catch(e){u.error(e);break}if(!L)break;if(b.address!==e||v.chainId!==t)break;if(!ue)break;try{s=yield L.getTransactionReceipt(i.hash)}catch(e){u.error(e);continue}if(b.address!==e||v.chainId!==t)break;if(!ue)break;const d={hash:i.hash};let l=!1;if(s&&s.blockHash){if(void 0!==s.status){const e=1===s.status;d.status=e?"success":"failure",e&&(d.events=[])}else s.logs.length>0?d.status="success":d.status="mined";if(i.eventsABI&&s.logs.length>0){const e=new r.Interface(i.eventsABI);d.events=s.logs.reduce((t,o)=>{let n;try{n=e.parseLog(o)}catch(e){u.error(e)}if(n){const e={};for(const t of Object.keys(n.args)){const o=n.args[t];e[t]=JSON.parse(JSON.stringify(o))}const o={args:e,name:n.name,signature:n.signature};t.push(o)}return t},[])}d.blockHash=s.blockHash,d.confirmations=s.confirmations,s.confirmations>=o&&(d.finalized=!0,(i.acknowledged||U.transactions.autoDelete)&&(l=!0))}else a>i.nonce?(d.status="cancelled",d.finalized=!0,d.confirmations=Math.max(1,o),(i.acknowledged||U.transactions.autoDelete)&&(l=!0)):c>i.nonce?(d.status="cancelled",d.confirmations=1):(d.status="pending",d.confirmations=0),d.blockHash=void 0,d.blockNumber=void 0,d.events=void 0;if(i.status!==d.status&&(d.acknowledged=!1),l)Re(i.hash);else{d.lastCheck=n.timestamp;try{ke(e,t,d,!0)}catch(e){u.error(e)}}}Pe=!1})}function Re(e){if(u.log(`deleting  ${e}`),b.address&&v.chainId){const t=y.findIndex(t=>t.hash===e);y.splice(t,1);try{localStorage.setItem(P+`_${b.address.toLowerCase()}_${v.chainId}`,JSON.stringify(y))}catch(e){}C.set(y)}}t.default=(e=>{(U={builtin:{autoProbe:!!e.builtin&&e.builtin.autoProbe},flow:{autoSelect:!(!e.flow||!e.flow.autoSelect),autoUnlock:!(!e.flow||!e.flow.autoUnlock)},debug:e.debug||!1,chainConfigs:e.chainConfigs,options:e.options||[],autoSelectPrevious:!!e.autoSelectPrevious,localStoragePrefix:e.localStoragePrefix||"",transactions:{autoDelete:!e.transactions||void 0===e.transactions.autoDelete||e.transactions.autoDelete,finality:e.transactions&&e.transactions.finality||12,pollingPeriod:e.transactions&&e.transactions.pollingPeriod||10}}).options&&0!==U.options.length||(U.options=["builtin"]),N=U.localStoragePrefix+N,P=U.localStoragePrefix+P;const{debug:t,chainConfigs:r,builtin:i}=U;if(D=r,e.fallbackNode&&function(e,t){__awaiter(this,void 0,void 0,function*(){const r=new n.JsonRpcProvider(e);let i;R(_,{connecting:!0});try{i=(yield r.getNetwork()).chainId}catch(e){const t={code:l.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw R(_,{error:t,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(t.message)}const a=String(i);R(_,{chainId:a,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"}),R(_,{loadingData:!0}),"function"==typeof t&&(t=yield t(a));const s={},c={};let d;try{d=re(t,a)}catch(e){throw R(_,{error:e,chainId:a,connecting:!1,loadingData:!1,state:"Connected"}),new Error(e.message||e)}for(const e of Object.keys(d)){const t=d[e];t.abi&&(u.log({contractName:e}),s[e]=new o.Contract(t.address,t.abi,r)),c[e]=t.address}R(_,{state:"Ready",loadingData:!1,connecting:!1,chainId:a,addresses:c,contracts:s})})}(e.fallbackNode,r),t&&"undefined"!=typeof window&&(window.$wallet=b,window.$transactions=y),j=U.options,R(I,{state:"Idle",options:j.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),R(k,{state:"Idle"}),R(x,{state:"Idle"}),R(S,{state:"Idle"}),g){if(e.autoSelectPrevious){const e=function(){try{return localStorage.getItem(N)}catch(e){return null}}();e&&""!==e&&ce(e)}i.autoProbe&&ge()}return{transactions:{subscribe:C.subscribe,acknowledge(e,t){if(b.address&&v.chainId){const o=y.find(t=>t.hash===e);if(o)if(o.finalized)Re(e);else{o.lastAcknowledgment=t,o.acknowledged=!0;try{localStorage.setItem(P+`_${b.address.toLowerCase()}_${v.chainId}`,JSON.stringify(y))}catch(e){}C.set(y)}}}},balance:{subscribe:S.subscribe,acknowledgeError:he(S)},chain:{subscribe:x.subscribe,acknowledgeError:he(x),get contracts(){return v.contracts}},fallback:{subscribe:_.subscribe,get contracts(){return m.contracts},get state(){return m.state}},builtin:{subscribe:k.subscribe,acknowledgeError:he(k),probe:ge},wallet:{subscribe:I.subscribe,connect:fe,unlock:be,acknowledgeError:he(I),disconnect:me,get options(){return b.options},get address(){return b.address},get provider(){return L},get web3Provider(){return A},get chain(){return v},get contracts(){return v.contracts},get balance(){return h.amount}},flow:{subscribe:E.subscribe,execute:ye,retry:we,cancel:Ce,connect:pe}}})});