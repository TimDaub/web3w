"use strict";var __awaiter=this&&this.__awaiter||function(e,t,o,n){return new(o||(o=Promise))(function(r,i){function s(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof o?t:new o(function(e){e(t)})).then(s,a)}c((n=n.apply(e,t||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const contracts_1=require("@ethersproject/contracts"),providers_1=require("@ethersproject/providers"),store_1=require("./utils/store"),builtin_1=require("./utils/builtin"),index_js_1=require("./utils/index.js"),ethers_1=require("./utils/ethers"),named_logs_1=require("named-logs"),console=named_logs_1.logs("web3w:index"),isBrowser="undefined"!=typeof window,$builtin={state:"Idle",loading:!1,available:void 0,error:void 0,vendor:void 0},$balance={state:"Idle",loading:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},$chain={state:"Idle",loading:!1,contracts:{},error:void 0},$wallet={state:"Idle",loading:!1,unlocking:!1,address:void 0,options:void 0,selected:void 0,pendingUserConfirmation:void 0,error:void 0};function store(e){const t=store_1.writable(e);return t.data=e,t}const $transactions=[],walletStore=store($wallet),transactionsStore=store($transactions),builtinStore=store($builtin),chainStore=store($chain),balanceStore=store($balance);function addTransaction(e){$transactions.push(e),transactionsStore.set($transactions)}function set(e,t){for(const o of Object.keys(t)){const n=t,r=e;if(r.data[o]&&"object"==typeof n[o])for(const e of Object.keys(n[o]))r.data[o][e]=n[o][e];else r.data[o]=n[o]}try{console.debug(JSON.stringify(e.data,null,"  "))}catch(t){console.error(t,e.data)}e.set(e.data)}function reset(e,t){"string"==typeof t&&(t=[t]);const o=e;for(const e of t){const t=o.data[e];o.data[e]="object"==typeof t?{status:void 0}:void 0}e.set(e.data)}let _ethersProvider,_web3Provider,_builtinEthersProvider,_builtinWeb3Provider,_chainConfigs,_currentModule,_options;function onChainChanged(...e){console.debug("onChainChanged",...e)}function onAccountsChanged(...e){console.debug("onAccountsChanged",...e)}function listenForChanges(e){_web3Provider&&(console.debug("listenning for changes..."),_web3Provider.on("chainChanged",onChainChanged),_web3Provider.on("accountsChanged",onAccountsChanged))}function stopListeningForChanges(){_web3Provider&&(console.debug("stop listenning for changes..."),_web3Provider.removeListener("chainChanged",onChainChanged),_web3Provider.removeListener("accountsChanged",onAccountsChanged))}function onConnect(...e){console.debug("onConnect",...e)}function onDisconnect(...e){console.debug("onDisconnect",...e)}function listenForConnection(){_web3Provider&&(console.debug("listenning for connection..."),_web3Provider.on("connect",onConnect),_web3Provider.on("disconnect",onDisconnect))}function stopListeningForConnection(){_web3Provider&&(console.debug("stop listenning for connection..."),_web3Provider.removeListener("connect",onConnect),_web3Provider.removeListener("disconnect",onDisconnect))}function isHex(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function toDecimal(e){return isHex(e)?""+parseInt(e.slice(2)):e}function toHex(e){return isHex(e)?e:"0x"+parseInt(e).toString(16)}function requestUserAttention(e){$wallet.pendingUserConfirmation?$wallet.pendingUserConfirmation.push(e):$wallet.pendingUserConfirmation=[e],set(walletStore,{pendingUserConfirmation:$wallet.pendingUserConfirmation})}function cancelUserAttention(e){if($wallet.pendingUserConfirmation){const t=$wallet.pendingUserConfirmation.indexOf(e);t>=0&&($wallet.pendingUserConfirmation.splice(t,1),0===$wallet.pendingUserConfirmation.length&&($wallet.pendingUserConfirmation=void 0),set(walletStore,{pendingUserConfirmation:$wallet.pendingUserConfirmation}))}}const _observers={onTxRequested:e=>{requestUserAttention("transaction")},onTxCancelled:e=>{cancelUserAttention("transaction")},onTxSent:e=>{cancelUserAttention("transaction")},onSignatureRequested:e=>{requestUserAttention("signature")},onSignatureCancelled:e=>{cancelUserAttention("signature")},onSignatureReceived:e=>{cancelUserAttention("signature")},onContractTxRequested:({name:e,method:t,overrides:o,outcome:n})=>{console.debug("onContractTxRequest",{name:e,method:t,overrides:o,outcome:n})},onContractTxCancelled:({name:e,method:t,overrides:o,outcome:n})=>{console.debug("onContractTxCancelled",{name:e,method:t,overrides:o,outcome:n})},onContractTxSent:({hash:e,name:t,method:o,overrides:n,outcome:r})=>{e?addTransaction({hash:e,name:t,method:o,overrides:n,outcome:r}):console.debug("onContractTxSent",{hash:e,name:t,method:o,overrides:n,outcome:r})}},LOCAL_STORAGE_SLOT="_web3w_previous_wallet_type";function recordSelection(e){localStorage.setItem(LOCAL_STORAGE_SLOT,e)}function fetchPreviousSelection(){return localStorage.getItem(LOCAL_STORAGE_SLOT)}function setupChain(e){return __awaiter(this,void 0,void 0,function*(){if(null===_ethersProvider){const e={message:"no provider setup yet"};throw set(chainStore,{error:e,loading:!1,state:"Idle"}),new Error(e.message)}set(chainStore,{loading:!0});const t={},o={};let n={};const{chainId:r}=yield _ethersProvider.getNetwork(),i=String(r);let s=_chainConfigs;if("function"==typeof s&&(s=yield s(i)),s){if(s.chainId){const e=s;if(i!==e.chainId&&i!=toDecimal(e.chainId)){const t={message:`chainConfig only available for ${e.chainId} , not available for ${i}`};throw set(chainStore,{error:t,chainId:i,notSupported:!0,loading:!1,state:"Idle"}),new Error(t.message)}n=e.contracts}else{const e=s,t=e[i]||e[toHex(i)];if(!t){const e={message:`chainConfig not available for ${i}`};throw set(chainStore,{error:e,chainId:i,notSupported:!0,loading:!1,state:"Idle"}),new Error(e.message)}n=t.contracts}for(const r of Object.keys(n)){if("status"===r){const e={message:'invalid name for contract : "status"'};throw set(chainStore,{error:e,state:"Idle",loading:!1}),new Error(e.message)}if("error"===r){const e={message:'invalid name for contract : "error"'};throw set(chainStore,{error:e,state:"Idle",loading:!1}),new Error(e.message)}const i=n[r];i.abi&&(t[r]=ethers_1.proxyContract(new contracts_1.Contract(i.address,i.abi,_ethersProvider.getSigner(e)),r,_observers)),o[r]=i.address}}set(chainStore,{state:"Ready",loading:void 0,chainId:i,addresses:o,contracts:t})})}function select(e,t){return __awaiter(this,void 0,void 0,function*(){!$wallet.selected||"Ready"!==$wallet.state&&"Locked"!==$wallet.state||(yield logout());let o,n=e;if(!n)if(0===_options.length)n="builtin";else{if(1!==_options.length){const e=`No Wallet Type Specified, choose from ${$wallet.options}`;throw new Error(e)}n=_options[0]}if("builtin"==n&&"Ready"===$builtin.state&&!$builtin.available){throw new Error("No Builtin Wallet")}if(set(walletStore,{address:void 0,loading:!0,selected:e,state:"Idle",error:void 0}),_ethersProvider=null,_web3Provider=null,"builtin"===n)_currentModule=void 0,yield probeBuiltin(),_ethersProvider=_builtinEthersProvider,_web3Provider=_builtinWeb3Provider;else{let o;if("string"==typeof n){if(_options)for(const t of _options)"string"!=typeof t&&t.id===e&&(o=t)}else e=(o=n).id;if(!o){const t=`no module found ${e}`;throw set(walletStore,{error:{message:t,code:1},selected:void 0,loading:!1}),new Error(t)}try{const{chainId:e,web3Provider:n}=yield o.setup(t);_web3Provider=n,_ethersProvider=ethers_1.proxyWeb3Provider(new providers_1.Web3Provider(_web3Provider),_observers),_currentModule=o}catch(e){throw"USER_CANCELED"===e.message?set(walletStore,{loading:!1,selected:void 0}):set(walletStore,{error:{message:e.message},selected:void 0,loading:!1}),e}}if(!_ethersProvider){const t=`no provider found for wallet type ${e}`;throw set(walletStore,{error:{message:t,code:1},selected:void 0,loading:!1}),new Error(t)}listenForConnection();try{o="builtin"===e&&"Metamask"===$builtin.vendor?yield index_js_1.timeout(2e3,_ethersProvider.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'}):yield index_js_1.timeout(2e4,_ethersProvider.listAccounts())}catch(e){throw set(walletStore,{error:e,selected:void 0,loading:!1}),e}recordSelection(e);const r=o&&o[0];r?(set(walletStore,{address:r,state:"Ready",loading:void 0}),listenForChanges(r),yield setupChain(r)):set(walletStore,{address:void 0,state:"Locked",loading:void 0})})}let probing,unlocking;function probeBuiltin(e={}){return probing||(probing=new Promise((e,t)=>__awaiter(this,void 0,void 0,function*(){if("Ready"===$builtin.state)return e();set(builtinStore,{loading:!0});try{const e=yield builtin_1.fetchEthereum();e?(_builtinWeb3Provider=e,_builtinEthersProvider=ethers_1.proxyWeb3Provider(new providers_1.Web3Provider(e),_observers),set(builtinStore,{state:"Ready",vendor:builtin_1.getVendor(e),available:!0,loading:void 0})):set(builtinStore,{state:"Ready",vendor:void 0,available:!1,loading:void 0})}catch(e){return set(builtinStore,{error:e.message||e,vendor:void 0,available:void 0,loading:!1}),t(e)}e()})))}function connect(e,t){return __awaiter(this,void 0,void 0,function*(){return yield select(e,t),"Locked"!==$wallet.state||unlock()})}function acknowledgeError(e){logout()}function logout(){return __awaiter(this,void 0,void 0,function*(){stopListeningForChanges(),stopListeningForConnection(),_currentModule&&(yield _currentModule.logout(),_currentModule=void 0),set(walletStore,{state:"Idle",address:void 0,loading:!1,unlocking:void 0,selected:void 0,error:void 0}),set(balanceStore,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),set(chainStore,{contracts:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),recordSelection("")})}function unlock(){if(unlocking)return unlocking;let e=!1;const t=new Promise((t,o)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===$wallet.state){let o;set(walletStore,{unlocking:!0});try{o=(o=yield null==_ethersProvider?void 0:_ethersProvider.send("eth_requestAccounts",[]))||[]}catch(e){o=[]}if(!(o.length>0))return set(walletStore,{unlocking:!1}),unlocking=void 0,e=!0,t(!1);{const e=o[0];set(walletStore,{address:e,state:"Ready",unlocking:void 0}),yield setupChain(e)}return unlocking=void 0,e=!0,t(!0)}return e=!0,o(new Error("Not Locked"))}));return e||(unlocking=t),t}exports.default=(e=>{(e=Object.assign({},e||{})).builtin=e.builtin||{};const{debug:t,chainConfigs:o,builtin:n}=e;if(_chainConfigs=o,t&&"undefined"!=typeof window&&(window.$wallet=$wallet,window.$transactions=$transactions),_options=e.options||[],set(walletStore,{state:"Idle",options:_options.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),set(builtinStore,{state:"Idle"}),set(chainStore,{state:"Idle"}),set(balanceStore,{state:"Idle"}),isBrowser){if(e.autoSelectPrevious){const e=fetchPreviousSelection();e&&""!==e&&select(e)}e.builtin.autoProbe&&probeBuiltin(e.builtin)}return{transactions:{subscribe:transactionsStore.subscribe},balance:{subscribe:balanceStore.subscribe},chain:{subscribe:chainStore.subscribe},builtin:{subscribe:builtinStore.subscribe,probe:probeBuiltin},wallet:{subscribe:walletStore.subscribe,connect:connect,unlock:unlock,acknowledgeError:acknowledgeError,logout:logout,get address(){return $wallet.address},get provider(){return _ethersProvider},get web3Provider(){return _web3Provider},get chain(){return $chain},get contracts(){return $chain.contracts},get balance(){return $balance.amount}}}});