var __awaiter=this&&this.__awaiter||function(e,o,t,n){return new(t||(t=Promise))(function(r,i){function s(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var o;e.done?r(e.value):(o=e.value,o instanceof t?o:new t(function(e){e(o)})).then(s,a)}c((n=n.apply(e,o||[])).next())})};import{Contract}from"@ethersproject/contracts";import{Web3Provider}from"@ethersproject/providers";import{writable}from"./utils/store";import{fetchEthereum,getVendor}from"./utils/builtin";import{timeout}from"./utils/index.js";import{proxyContract,proxyWeb3Provider}from"./utils/ethers";import{logs}from"named-logs";import{CHAIN_NO_PROVIDER,CHAIN_CONFIG_NOT_AVAILABLE,MODULE_ERROR}from"./errors";const console=logs("web3w:index"),isBrowser="undefined"!=typeof window,$builtin={state:"Idle",loading:!1,available:void 0,error:void 0,vendor:void 0},$balance={state:"Idle",loading:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},$chain={state:"Idle",loading:!1,contracts:{},error:void 0},$wallet={state:"Idle",loading:!1,unlocking:!1,address:void 0,options:void 0,selected:void 0,pendingUserConfirmation:void 0,error:void 0};function store(e){const o=writable(e);return o.data=e,o}const $transactions=[],walletStore=store($wallet),transactionsStore=store($transactions),builtinStore=store($builtin),chainStore=store($chain),balanceStore=store($balance);function addTransaction(e){$transactions.push(e),transactionsStore.set($transactions)}function set(e,o){for(const t of Object.keys(o)){const n=o,r=e;if(r.data[t]&&"object"==typeof n[t])for(const e of Object.keys(n[t]))r.data[t][e]=n[t][e];else r.data[t]=n[t]}try{console.debug(JSON.stringify(e.data,null,"  "))}catch(o){console.error(o,e.data)}e.set(e.data)}let _ethersProvider,_web3Provider,_builtinEthersProvider,_builtinWeb3Provider,_chainConfigs,_currentModule,_options;function onChainChanged(e){console.debug("onChainChanged",{chainId:e})}function onAccountsChanged(e){console.debug("onAccountsChanged",{accounts:e})}function listenForChanges(e){_web3Provider&&(console.debug("listenning for changes...",{address:e}),_web3Provider.on("chainChanged",onChainChanged),_web3Provider.on("accountsChanged",onAccountsChanged))}function stopListeningForChanges(){_web3Provider&&(console.debug("stop listenning for changes..."),_web3Provider.removeListener("chainChanged",onChainChanged),_web3Provider.removeListener("accountsChanged",onAccountsChanged))}function onConnect({chainId:e}){console.debug("onConnect",{chainId:e})}function onDisconnect(e){console.debug("onDisconnect",{error:e})}function listenForConnection(){_web3Provider&&(console.debug("listenning for connection..."),_web3Provider.on("connect",onConnect),_web3Provider.on("disconnect",onDisconnect))}function stopListeningForConnection(){_web3Provider&&(console.debug("stop listenning for connection..."),_web3Provider.removeListener("connect",onConnect),_web3Provider.removeListener("disconnect",onDisconnect))}function isHex(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function toDecimal(e){return isHex(e)?""+parseInt(e.slice(2)):e}function toHex(e){return isHex(e)?e:"0x"+parseInt(e).toString(16)}function requestUserAttention(e){$wallet.pendingUserConfirmation?$wallet.pendingUserConfirmation.push(e):$wallet.pendingUserConfirmation=[e],set(walletStore,{pendingUserConfirmation:$wallet.pendingUserConfirmation})}function cancelUserAttention(e){if($wallet.pendingUserConfirmation){const o=$wallet.pendingUserConfirmation.indexOf(e);o>=0&&($wallet.pendingUserConfirmation.splice(o,1),0===$wallet.pendingUserConfirmation.length&&($wallet.pendingUserConfirmation=void 0),set(walletStore,{pendingUserConfirmation:$wallet.pendingUserConfirmation}))}}const _observers={onTxRequested:e=>{console.debug("onTxRequested",{transaction:e}),requestUserAttention("transaction")},onTxCancelled:e=>{console.debug("onTxCancelled",{transaction:e}),cancelUserAttention("transaction")},onTxSent:e=>{console.debug("onTxSent",{transaction:e}),cancelUserAttention("transaction")},onSignatureRequested:e=>{console.debug("onSignatureRequested",{message:e}),requestUserAttention("signature")},onSignatureCancelled:e=>{console.debug("onSignatureCancelled",{message:e}),cancelUserAttention("signature")},onSignatureReceived:e=>{console.debug("onSignatureReceived",{signature:e}),cancelUserAttention("signature")},onContractTxRequested:({name:e,method:o,overrides:t,outcome:n})=>{console.debug("onContractTxRequest",{name:e,method:o,overrides:t,outcome:n})},onContractTxCancelled:({name:e,method:o,overrides:t,outcome:n})=>{console.debug("onContractTxCancelled",{name:e,method:o,overrides:t,outcome:n})},onContractTxSent:({hash:e,name:o,method:t,overrides:n,outcome:r})=>{console.debug("onContractTxSent",{hash:e,name:o,method:t,overrides:n,outcome:r}),e&&addTransaction({hash:e,name:o,method:t,overrides:n,outcome:r})}},LOCAL_STORAGE_SLOT="_web3w_previous_wallet_type";function recordSelection(e){localStorage.setItem(LOCAL_STORAGE_SLOT,e)}function fetchPreviousSelection(){return localStorage.getItem(LOCAL_STORAGE_SLOT)}function setupChain(e){return __awaiter(this,void 0,void 0,function*(){if(void 0===_ethersProvider){const e={code:CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw set(chainStore,{error:e,loading:!1,state:"Idle"}),new Error(e.message)}set(chainStore,{loading:!0});const o={},t={};let n={};const{chainId:r}=yield _ethersProvider.getNetwork(),i=String(r);let s=_chainConfigs;if("function"==typeof s&&(s=yield s(i)),s){if(s.chainId){const e=s;if(i!==e.chainId&&i!=toDecimal(e.chainId)){const o={code:CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${e.chainId} , not available for ${i}`};throw set(chainStore,{error:o,chainId:i,notSupported:!0,loading:!1,state:"Idle"}),new Error(o.message)}n=e.contracts}else{const e=s,o=e[i]||e[toHex(i)];if(!o){const e={code:CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${i}`};throw set(chainStore,{error:e,chainId:i,notSupported:!0,loading:!1,state:"Idle"}),new Error(e.message)}n=o.contracts}for(const r of Object.keys(n)){const i=n[r];i.abi&&(o[r]=proxyContract(new Contract(i.address,i.abi,_ethersProvider.getSigner(e)),r,_observers)),t[r]=i.address}}set(chainStore,{state:"Ready",loading:void 0,chainId:i,addresses:t,contracts:o})})}function select(e,o){return __awaiter(this,void 0,void 0,function*(){!$wallet.selected||"Ready"!==$wallet.state&&"Locked"!==$wallet.state||(yield logout());let t,n=e;if(!n)if(0===_options.length)n="builtin";else{if(1!==_options.length){const e=`No Wallet Type Specified, choose from ${$wallet.options}`;throw new Error(e)}n=_options[0]}if("builtin"==n&&"Ready"===$builtin.state&&!$builtin.available){throw new Error("No Builtin Wallet")}if(set(walletStore,{address:void 0,loading:!0,selected:e,state:"Idle",error:void 0}),_ethersProvider=void 0,_web3Provider=void 0,"builtin"===n)_currentModule=void 0,yield probeBuiltin(),_ethersProvider=_builtinEthersProvider,_web3Provider=_builtinWeb3Provider;else{let t;if("string"==typeof n){if(_options)for(const o of _options)"string"!=typeof o&&o.id===e&&(t=o)}else e=(t=n).id;if(!t){const o=`no module found ${e}`;throw set(walletStore,{error:{message:o,code:1},selected:void 0,loading:!1}),new Error(o)}try{const{web3Provider:e}=yield t.setup(o);_ethersProvider=proxyWeb3Provider(new Web3Provider(_web3Provider=e),_observers),_currentModule=t}catch(e){throw"USER_CANCELED"===e.message?set(walletStore,{loading:!1,selected:void 0}):set(walletStore,{error:{code:MODULE_ERROR,message:e.message},selected:void 0,loading:!1}),e}}if(!_ethersProvider){const o=`no provider found for wallet type ${e}`;throw set(walletStore,{error:{message:o,code:1},selected:void 0,loading:!1}),new Error(o)}listenForConnection();try{t="builtin"===e&&"Metamask"===$builtin.vendor?yield timeout(2e3,_ethersProvider.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'}):yield timeout(2e4,_ethersProvider.listAccounts())}catch(e){throw set(walletStore,{error:e,selected:void 0,loading:!1}),e}recordSelection(e);const r=t&&t[0];r?(set(walletStore,{address:r,state:"Ready",loading:void 0}),listenForChanges(r),yield setupChain(r)):set(walletStore,{address:void 0,state:"Locked",loading:void 0})})}let probing,unlocking;function probeBuiltin(){return probing||(probing=new Promise((e,o)=>__awaiter(this,void 0,void 0,function*(){if("Ready"===$builtin.state)return e();set(builtinStore,{loading:!0});try{const e=yield fetchEthereum();e?(_builtinWeb3Provider=e,_builtinEthersProvider=proxyWeb3Provider(new Web3Provider(e),_observers),set(builtinStore,{state:"Ready",vendor:getVendor(e),available:!0,loading:void 0})):set(builtinStore,{state:"Ready",vendor:void 0,available:!1,loading:void 0})}catch(e){return set(builtinStore,{error:e.message||e,vendor:void 0,available:void 0,loading:!1}),o(e)}e()})))}function connect(e,o){return __awaiter(this,void 0,void 0,function*(){return yield select(e,o),"Locked"!==$wallet.state||unlock()})}function acknowledgeError(e){logout()}function logout(){return __awaiter(this,void 0,void 0,function*(){stopListeningForChanges(),stopListeningForConnection(),_currentModule&&(yield _currentModule.logout(),_currentModule=void 0),set(walletStore,{state:"Idle",address:void 0,loading:!1,unlocking:void 0,selected:void 0,error:void 0}),set(balanceStore,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),set(chainStore,{contracts:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),recordSelection("")})}function unlock(){if(unlocking)return unlocking;let e=!1;const o=new Promise((o,t)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===$wallet.state){let t;set(walletStore,{unlocking:!0});try{t=(t=yield null==_ethersProvider?void 0:_ethersProvider.send("eth_requestAccounts",[]))||[]}catch(e){t=[]}if(!(t.length>0))return set(walletStore,{unlocking:!1}),unlocking=void 0,e=!0,o(!1);{const e=t[0];set(walletStore,{address:e,state:"Ready",unlocking:void 0}),yield setupChain(e)}return unlocking=void 0,e=!0,o(!0)}return e=!0,t(new Error("Not Locked"))}));return e||(unlocking=o),o}export default e=>{(e=Object.assign({},e||{})).builtin=e.builtin||{autoProbe:!1};const{debug:o,chainConfigs:t,builtin:n}=e;if(_chainConfigs=t,o&&"undefined"!=typeof window&&(window.$wallet=$wallet,window.$transactions=$transactions),_options=e.options||[],set(walletStore,{state:"Idle",options:_options.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),set(builtinStore,{state:"Idle"}),set(chainStore,{state:"Idle"}),set(balanceStore,{state:"Idle"}),isBrowser){if(e.autoSelectPrevious){const e=fetchPreviousSelection();e&&""!==e&&select(e)}n.autoProbe&&probeBuiltin()}return{transactions:{subscribe:transactionsStore.subscribe},balance:{subscribe:balanceStore.subscribe},chain:{subscribe:chainStore.subscribe},builtin:{subscribe:builtinStore.subscribe,probe:probeBuiltin},wallet:{subscribe:walletStore.subscribe,connect:connect,unlock:unlock,acknowledgeError:acknowledgeError,logout:logout,get address(){return $wallet.address},get provider(){return _ethersProvider},get web3Provider(){return _web3Provider},get chain(){return $chain},get contracts(){return $chain.contracts},get balance(){return $balance.amount}}}};