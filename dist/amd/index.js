"use strict";var __awaiter=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))(function(r,i){function a(e){try{c(o.next(e))}catch(e){i(e)}}function s(e){try{c(o.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(a,s)}c((o=o.apply(e,t||[])).next())})};define("errors",["require","exports"],function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.CHAIN_ID_NOT_SET=t.CHAIN_ID_FAILED=t.MODULE_ERROR=t.CHAIN_CONFIG_NOT_AVAILABLE=t.CHAIN_NO_PROVIDER=void 0,t.CHAIN_NO_PROVIDER=6e3,t.CHAIN_CONFIG_NOT_AVAILABLE=6001,t.MODULE_ERROR=1e3,t.CHAIN_ID_FAILED=2001,t.CHAIN_ID_NOT_SET=2002}),define("utils/internals",["require","exports"],function(e,t){function n(e,n,o){if(null==e)return t.noop;const r=e.subscribe(n,o);return r.unsubscribe?()=>r.unsubscribe():r}Object.defineProperty(t,"__esModule",{value:!0}),t.get_store_value=t.safe_not_equal=t.subscribe=t.noop=void 0,t.noop=(()=>void 0),t.subscribe=n,t.safe_not_equal=function(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e},t.get_store_value=function(e){let t;return n(e,e=>t=e)(),t}}),define("utils/store",["require","exports","utils/internals"],function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.get=t.writable=t.readable=void 0,Object.defineProperty(t,"get",{enumerable:!0,get:function(){return n.get_store_value}});const o=[];function r(e,t=n.noop){let r=null;const i=[];function a(t){if(n.safe_not_equal(e,t)&&(e=t,r)){const t=!o.length;for(let t=0;t<i.length;t+=1){const n=i[t];n[1](),o.push(n,e)}if(t){for(let e=0;e<o.length;e+=2)o[e][0](o[e+1]);o.length=0}}}return{set:a,update:function(t){a(t(e))},subscribe:function(o,s=n.noop){const c=[o,s];return i.push(c),1===i.length&&(r=t(a)||n.noop),o(e),()=>{const e=i.indexOf(c);-1!==e&&i.splice(e,1),0===i.length&&null!==r&&(r(),r=null)}}}}t.readable=function(e,t){return{subscribe:r(e,t).subscribe}},t.writable=r}),define("utils/builtin",["require","exports"],function(e,t){function n(){if("undefined"!=typeof window){const e=window;if(e.ethereum)return e.ethereum;if(e.web3)return e.web3.currentProvider}return null}Object.defineProperty(t,"__esModule",{value:!0}),t.getVendor=t.fetchEthereum=t.getEthereum=void 0,t.getEthereum=n,t.fetchEthereum=function(){return new Promise(e=>{"complete"!==document.readyState?document.onreadystatechange=function(){"complete"===document.readyState&&(document.onreadystatechange=null,e(n()))}:e(n())})},t.getVendor=function(e){return e?e.isMetaMask?"Metamask":-1!=navigator.userAgent.indexOf("Opera")||-1!=navigator.userAgent.indexOf("OPR/")?"Opera":"unknown":void 0}}),define("utils/index",["require","exports"],function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.timeout=void 0,t.timeout=function(e,t,n){return new Promise((o,r)=>{let i=!1;const a=setTimeout(()=>{i=!0,n?"function"==typeof n?o(n()):r(n.error||n):r(new Error("TimedOut"))},e);t.then(e=>{i||(clearTimeout(a),o(e))}).catch(e=>{i||(clearTimeout(a),r(e))})})}}),define("utils/ethers",["require","exports","utils/internals","named-logs"],function(e,t,n,o){Object.defineProperty(t,"__esModule",{value:!0}),t.proxyWeb3Provider=t.proxyContract=void 0;const r=o.logs("web3w:ethers");function i(e,t,{onTxRequested:n,onTxCancelled:o,onTxSent:r,onSignatureRequested:i,onSignatureCancelled:a,onSignatureReceived:s}){t=Object.assign({sendTransaction:(t,i,a)=>__awaiter(this,void 0,void 0,function*(){const s=yield e.getAddress(),c=yield(yield e.getChainId()).toString(),d=Object.assign(Object.assign({},a[0]),{from:s,chainId:c});let u;n(d);try{u=yield t.bind(i)(...a)}catch(e){throw o(d),e}const l=(yield e.provider.getBlock("latest")).timestamp;return r(Object.assign(Object.assign({},u),{submissionBlockTime:l,chainId:c})),u}),signMessage:(t,n,o)=>__awaiter(this,void 0,void 0,function*(){const r=yield e.getAddress(),c={from:r,message:o[0]};let d;i(c);try{d=yield t.bind(n)(...o)}catch(e){throw a(c),e}return s({from:r,signature:d}),d})},t);const c={};return new Proxy(e,{get:(n,o)=>{const r=t[o];return r?function(t,n){let o=c[t];return o||(o=new Proxy(e[t],n),c[t]=o),o}(o,{apply:r}):n[o]}})}function a(e,t){return i(e,{connectUnchecked:(e,n,o)=>{return function(e,t){return i(e,{},t)}(e.bind(n)(...o),t)}},t)}t.proxyContract=function e(t,o,i,a){r.log("PROXY",{name:o});const s=a?Object.assign({onContractTxRequested:n.noop,onContractTxCancelled:n.noop,onContractTxSent:n.noop},a):{onContractTxRequested:n.noop,onContractTxCancelled:n.noop,onContractTxSent:n.noop},{onContractTxRequested:c,onContractTxCancelled:d,onContractTxSent:u}=s,l={},g={},f=t.interface.fragments.filter(e=>"event"===e.type).map(e=>JSON.parse(e.format("json"))),h=t.interface.functions,v={};for(const e of Object.keys(h))v[h[e].name]=e;const m={};for(const e of Object.keys(t))m[e]=t[e];m.functions={};for(const e of Object.keys(t.functions))m.functions[e]=t.functions[e];function b(e,n,r){let a=e[r];if(!a){let s=t.interface.functions[r];s||(s=t.interface.functions[v[r]]),a=new Proxy(n[r],{apply:(e,a,l)=>__awaiter(this,void 0,void 0,function*(){const a=yield t.signer.getAddress(),g=l.length;let h,v,m,b=l;g===s.inputs.length+1&&"object"==typeof l[g-1]&&(b=b.slice(0,g-1),h=l[g]),h&&(v=h.metadata,delete(h=Object.assign({},h)).metadata),c({to:t.address,from:a,chainId:i,eventsABI:f,contractName:o,args:b,method:r,overrides:h,metadata:v});try{m=yield e.bind(n)(...l)}catch(e){throw d({to:t.address,from:a,chainId:i,eventsABI:f,contractName:o,args:b,method:r,overrides:h,metadata:v}),e}return u({hash:m.hash,to:t.address,from:a,chainId:i,eventsABI:f,contractName:o,args:b,method:r,overrides:h,metadata:v}),m})}),e[r]=a}return a}const p=new Proxy(m.functions,{get:(e,n)=>b(l,t.functions,n)});return new Proxy(m,{get:(n,r)=>"functions"===r?p:t.functions[r]?b(g,t,r):"_proxiedContract"===r?t:"connect"===r?n=>e(t.connect(n),o,i,a):"toJSON"===r?()=>({address:t.address,abi:t.interface.fragments,functionsSignatures:t.interface.fragments.map(e=>e.format("full"))}):n[r]})},t.proxyWeb3Provider=function(e,t){const o=t?Object.assign({onTxRequested:n.noop,onTxCancelled:n.noop,onTxSent:n.noop,onSignatureRequested:n.noop,onSignatureCancelled:n.noop,onSignatureReceived:n.noop},t):{onTxRequested:n.noop,onTxCancelled:n.noop,onTxSent:n.noop,onSignatureRequested:n.noop,onSignatureCancelled:n.noop,onSignatureReceived:n.noop},r=new Proxy(e.getSigner,{apply:(t,n,r)=>a(t.bind(e)(...r),o)});return new Proxy(e,{get:(e,t)=>"getSigner"===t?r:e[t]})}}),define("index",["require","exports","@ethersproject/contracts","@ethersproject/providers","@ethersproject/abi","utils/store","utils/builtin","utils/index","utils/ethers","named-logs","errors"],function(e,t,n,o,r,i,a,s,c,d,u){Object.defineProperty(t,"__esModule",{value:!0});const l=d.logs("web3w:index"),g="undefined"!=typeof window,f={state:"Idle",probing:!1,available:void 0,error:void 0,vendor:void 0},h={state:"Idle",fetching:!1,stale:void 0,amount:void 0,error:void 0,blockNumber:void 0},v={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},m={state:"Idle",connecting:!1,loadingData:!1,contracts:void 0,error:void 0},b={state:"Idle",connecting:!1,disconnecting:!1,loadingModule:!1,unlocking:!1,address:void 0,options:["builtin"],selected:void 0,pendingUserConfirmation:void 0,error:void 0},p={inProgress:!1,executing:!1,executionError:void 0,error:void 0};function w(e){const t=i.writable(e);return t.data=e,t}const y=[],I=w(b),_=w(y),x=w(f),C=w(v),S=w(m),P=w(h),k=w(p);let E="_web3w_transactions",O="_web3w_previous_wallet_type";function N(e,t){for(const n of Object.keys(t)){const o=t,r=e;if(r.data[n]&&"object"==typeof o[n])for(const e of Object.keys(o[n]))r.data[n][e]=o[n][e];else r.data[n]=o[n]}try{l.debug(JSON.stringify(e.data,null,"  "))}catch(t){l.error(t,e.data)}e.set(e.data)}let R,A,T,L,D,j,q,M,U,H,$,B=!1;function F(e){return __awaiter(this,void 0,void 0,function*(){if("0xNaN"===e){if(l.warn("onChainChanged bug (return 0xNaN), metamask bug?"),!A)throw new Error("no web3Provider to get chainId");e=yield V(A,"eth_chainId")}const t=parseInt(e.slice(2),16).toString();l.debug("onChainChanged",{chainId:e,chainIdAsDecimal:t}),N(C,{contracts:void 0,addresses:void 0,state:"Connected",chainId:t,notSupported:void 0}),b.address&&(Pe(b.address,t),l.log("LOAD_CHAIN from chainChanged"),yield ie(t,b.address,!0))})}function J(e){return e[0]!==b.address}function W(e){return __awaiter(this,void 0,void 0,function*(){if(!J(e))return void l.debug("false account changed",e);l.debug("onAccountsChanged",{accounts:e});const t=e[0];if(t)if(N(I,{address:t,state:"Ready"}),v.chainId&&Pe(t,v.chainId),"Connected"===v.state){if(!v.chainId)throw new Error("no chainId while connected");l.log("LOAD_CHAIN from accountsChanged"),yield ie(v.chainId,t,!1)}else se(t);else Se(),N(I,{address:t,state:"Locked"}),se(t)})}function V(e,t,n){var o;if(e.request)return e.request({method:t,params:n});const r=null===(o=e.sendAsync)||void 0===o?void 0:o.bind(e);if(r)return new Promise((e,o)=>{r({method:t,params:n},(t,n)=>{t?o(t):n.error?o(n.error):e(n.result)})});throw new Error("provider not supported")}function G(e){return new Promise(t=>{setTimeout(t,e)})}function z(e,t){return __awaiter(this,void 0,void 0,function*(){for(;B;){let n=[];try{n=yield V(e,"eth_accounts")}catch(e){}if(l.debug({accounts:n}),B&&J(n))try{t(n)}catch(e){l.error(e)}yield G(3e3)}})}function Y(){A&&!B&&(l.log("LISTENNING"),A.on?(A.on("chainChanged",F),A.on("accountsChanged",W),z(A,W)):(!function(e,t){__awaiter(this,void 0,void 0,function*(){for(;B;){const n=yield V(e,"eth_chainId"),o=parseInt(n.slice(2),16).toString();if(B&&v.chainId!==o)try{t(n)}catch(e){l.error(e)}yield G(3e3)}})}(A,F),z(A,W)),B=!0)}function X(e){const t=e&&e.chainId;if(t){const e=parseInt(t.slice(2),16).toString();l.debug("onConnect",{chainId:t,chainIdAsDecimal:e})}else l.warn("onConnect","no connection object passed in")}function K(e){l.debug("onDisconnect",{error:e})}function Q(e){return"string"==typeof e&&e.length>2&&"0x"===e.slice(0,2).toLowerCase()}function Z(e){b.pendingUserConfirmation?b.pendingUserConfirmation.push(e):b.pendingUserConfirmation=[e],N(I,{pendingUserConfirmation:b.pendingUserConfirmation})}function ee(e){if(b.pendingUserConfirmation){const t=b.pendingUserConfirmation.indexOf(e);t>=0&&(b.pendingUserConfirmation.splice(t,1),0===b.pendingUserConfirmation.length&&(b.pendingUserConfirmation=void 0),N(I,{pendingUserConfirmation:b.pendingUserConfirmation}))}}const te={onTxRequested:e=>{l.debug("onTxRequested",{txRequest:e}),Z("transaction")},onTxCancelled:e=>{l.debug("onTxCancelled",{txRequest:e}),ee("transaction")},onTxSent:({hash:e,from:t,gasLimit:n,nonce:o,gasPrice:r,data:i,value:a,chainId:s,to:c,submissionBlockTime:d})=>{if(l.debug("onTxSent",{hash:e,from:t,gasLimit:n,nonce:o,gasPrice:r,data:i,value:a,chainId:s,to:c}),e){!function(e,t,n){Ce(e,t,n,!0)}(t,s,{hash:e,from:t,acknowledged:!1,status:"pending",to:c,nonce:o,gasLimit:n.toString(),gasPrice:r.toString(),data:i,value:a.toString(),submissionBlockTime:d,confirmations:0,finalized:!1})}ee("transaction")},onSignatureRequested:e=>{l.debug("onSignatureRequested",{sigRequest:e}),Z("signature")},onSignatureCancelled:e=>{l.debug("onSignatureCancelled",{sigRequest:e}),ee("signature")},onSignatureReceived:e=>{l.debug("onSignatureReceived",{sigResponse:e}),ee("signature")},onContractTxRequested:({from:e,contractName:t,method:n,overrides:o,metadata:r})=>{l.debug("onContractTxRequest",{from:e,contractName:t,method:n,overrides:o,metadata:r})},onContractTxCancelled:({from:e,contractName:t,method:n,overrides:o,metadata:r})=>{l.debug("onContractTxCancelled",{from:e,contractName:t,method:n,overrides:o,metadata:r})},onContractTxSent:({hash:e,from:t,contractName:n,method:o,args:r,eventsABI:i,overrides:a,metadata:s,to:c,chainId:d})=>{var u,g,f;if(l.debug("onContractTxSent",{hash:e,from:t,contractName:n,method:o,args:r,eventsABI:i,overrides:a,metadata:s,to:c}),e){let l;a&&a.nonce&&(l=parseInt(a.nonce.toString())),xe(t,d,{hash:e,from:t,acknowledged:!1,contractName:n,method:o,args:r,eventsABI:i,metadata:s,to:c,nonce:l,gasLimit:null===(u=null==a?void 0:a.gasLimit)||void 0===u?void 0:u.toString(),gasPrice:null===(g=null==a?void 0:a.gasPrice)||void 0===g?void 0:g.toString(),value:null===(f=null==a?void 0:a.value)||void 0===f?void 0:f.toString()},!1)}}};function ne(e){try{localStorage.setItem(O,e)}catch(e){}}function oe(e,t){return __awaiter(this,void 0,void 0,function*(){const n=ae(t);let o;if("Idle"===v.state){let e;N(C,{connecting:!0});try{0===(e=(yield n.getNetwork()).chainId)&&(e=1337,l.error("giving chainId = 0, assume local 1337?"))}catch(e){const t={code:u.CHAIN_ID_FAILED,message:"Failed to fetch chainId"};throw N(C,{error:t,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(t.message)}o=String(e),N(C,{chainId:o,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"})}else o=v.chainId;if(!o){const e={code:u.CHAIN_ID_NOT_SET,message:"chainId is not set even though chain is connected"};throw N(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}Pe(e,o),l.log("LOAD_CHAIN from setupChain"),yield ie(o,e,t)})}function re(e,t){if(e.chainId){const o=e;if(t===o.chainId||t==(Q(n=o.chainId)?""+parseInt(n.slice(2)):n))return o.contracts;throw{code:u.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig only available for ${o.chainId}, not available for ${t}`}}{const n=e,o=n[t]||n[function(e){return Q(e)?e:"0x"+parseInt(e).toString(16)}(t)];if(o)return o.contracts;throw{code:u.CHAIN_CONFIG_NOT_AVAILABLE,message:`chainConfig not available for ${t}`}}var n}function ie(e,t,o){return __awaiter(this,void 0,void 0,function*(){const r=ae(o);N(C,{loadingData:!0});const i={},a={};let s=L;if("function"==typeof s&&(s=yield s(e)),s){let o;try{o=re(s,e)}catch(t){throw N(C,{error:t,chainId:e,notSupported:!0,connecting:!1,loadingData:!1,state:"Connected"}),new Error(t.message||t)}for(const s of Object.keys(o)){const d=o[s];d.abi&&(l.log({contractName:s}),i[s]=c.proxyContract(new n.Contract(d.address,d.abi,r.getSigner(t)),s,e,te)),a[s]=d.address}}if(N(C,{state:"Ready",loadingData:!1,connecting:!1,chainId:e,addresses:a,contracts:i}),"Ready"===b.state&&(l.log("READY"),U&&void 0===p.executionError&&!p.executing)){l.log(" => executing...");const e=U;if($){let t;try{l.log("executing after chain Setup"),t=$(i)}catch(e){return void N(k,{executionError:e,executing:!1})}"then"in t?(N(k,{error:void 0,executionError:void 0,executing:!0}),t.then(()=>{N(k,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),e(i),M=void 0,H=void 0,U=void 0}).catch(e=>{N(k,{executionError:e,executing:!1})})):(N(k,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),U(i),M=void 0,H=void 0,U=void 0)}else N(k,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),U(i),M=void 0,H=void 0,U=void 0}})}function ae(e){if(void 0===R||void 0===A){const e={code:u.CHAIN_NO_PROVIDER,message:"no provider setup yet"};throw N(C,{error:e,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(e.message)}return e&&(R=c.proxyWeb3Provider(new o.Web3Provider(A),te)),R}function se(e){const t=ae(!1),n=v.contracts;if(n)for(const o of Object.keys(n))n[o]=n[o].connect(e?t.getSigner(e):t)}function ce(e,t){return __awaiter(this,void 0,void 0,function*(){!b.selected||"Ready"!==b.state&&"Locked"!==b.state||(yield me());let n,r=e;if(!r)if(0===j.length)r="builtin";else{if(1!==j.length){const e=`No Wallet Type Specified, choose from ${b.options}`;throw new Error(e)}r=j[0]}if("builtin"==r&&"Ready"===f.state&&!f.available){throw new Error("No Builtin Wallet")}if(N(I,{address:void 0,connecting:!0,selected:e,state:"Idle",error:void 0}),R=void 0,A=void 0,"builtin"===r){D=void 0;const e=yield ge();A=e,R=c.proxyWeb3Provider(new o.Web3Provider(e),te)}else{let n;if("string"==typeof r){if(j)for(const t of j)"string"!=typeof t&&t.id===e&&(n=t)}else e=(n=r).id;if(!n){const t=`no module found ${e}`;throw N(I,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}try{"load"in n&&(N(I,{loadingModule:!0}),n=yield n.load(),N(I,{loadingModule:!1})),l.log("setting up module");const{web3Provider:e}=yield n.setup(t);l.log("module setup"),A=e,R=c.proxyWeb3Provider(new o.Web3Provider(A),te),D=n}catch(e){throw"USER_CANCELED"===e.message?N(I,{connecting:!1,selected:void 0,loadingModule:!1}):N(I,{error:{code:u.MODULE_ERROR,message:e.message},selected:void 0,connecting:!1,loadingModule:!1}),e}}if(!R){const t=`no provider found for wallet type ${e}`;throw N(I,{error:{message:t,code:1},selected:void 0,connecting:!1}),new Error(t)}A&&(l.debug("listenning for connection..."),A.on&&A.on("connect",X),A.on&&A.on("disconnect",K));try{if("builtin"===e&&"Metamask"===f.vendor)n=yield s.timeout(2e3,R.listAccounts(),{error:'Metamask timed out. Please reload the page (see <a href="https://github.com/MetaMask/metamask-extension/issues/7221">here</a>)'});else{l.log("fetching accounts...");try{n=yield R.listAccounts()}catch(e){if(4100===e.code)l.log(`4100 ${e.name}`),n=[];else{if(-32500!==e.code||"permission denied"!==e.message)throw e;"Opera"===f.vendor?l.log("permission denied (opera) crypto wallet not enabled?)"):l.log("permission denied"),n=[]}}l.log(`accounts: ${n}`)}}catch(e){throw N(I,{error:e,selected:void 0,connecting:!1}),e}ne(e);const i=n&&n[0];i?(N(I,{address:i,state:"Ready",connecting:void 0}),Y(),l.log("SETUP_CHAIN from select"),yield oe(i,!1)):(Y(),N(I,{address:void 0,state:"Locked",connecting:void 0}))})}let de,ue,le;function ge(){return de||(de=new Promise((e,t)=>__awaiter(this,void 0,void 0,function*(){if(T&&"Ready"===f.state)return e(T);N(x,{probing:!0});try{const n=yield a.fetchEthereum();n?(n.autoRefreshOnNetworkChange=!1,T=n,N(x,{state:"Ready",vendor:a.getVendor(n),available:!0,probing:!1})):N(x,{state:"Ready",vendor:void 0,available:!1,probing:!1}),e(n)}catch(e){return N(x,{error:e.message||e,vendor:void 0,available:void 0,probing:!1}),t(e)}})))}function fe(e,t){return __awaiter(this,void 0,void 0,function*(){return yield ce(e,t),"Locked"!==b.state||be()})}function he(e){return()=>{N(e,{error:void 0})}}function ve(e){A&&B&&(l.log("STOP LISTENNING"),l.debug("stop listenning for changes..."),A.removeListener&&A.removeListener("chainChanged",F),A.removeListener&&A.removeListener("accountsChanged",W),B=!1),A&&(l.debug("stop listenning for connection..."),A.removeListener&&A.removeListener("connect",X),A.removeListener&&A.removeListener("disconnect",K)),N(I,{state:"Idle",address:void 0,connecting:!1,unlocking:void 0,selected:void 0,error:void 0}),Se(),N(P,{state:"Idle",amount:void 0,error:void 0,blockNumber:void 0}),N(C,{contracts:void 0,addresses:void 0,state:"Idle",notSupported:void 0,chainId:void 0,error:void 0}),e||(N(k,{error:void 0,executing:!1,executionError:void 0,inProgress:!1}),$=void 0,H=void 0,U=void 0,M=void 0),ne("")}function me(e){if(b.disconnecting)throw new Error("already disconnecting");const t=e&&e.logout,n=e&&e.wait,o=e&&e.keepFlow;return new Promise((e,r)=>{if(D)if(t){let t;try{t=D.logout()}catch(e){r(e)}n&&t&&"then"in t?(N(I,{disconnecting:!0}),t.then(()=>{D&&D.disconnect(),D=void 0,ve(o),N(I,{disconnecting:!1}),e()}).catch(e=>{N(I,{disconnecting:!1,error:e}),r(e)})):(D.disconnect(),D=void 0,ve(o),e())}else D.disconnect(),D=void 0,ve(o),e();else ve(o),e()})}function be(){if(ue)return ue;let e=!1;const t=new Promise((t,n)=>__awaiter(this,void 0,void 0,function*(){if("Locked"===b.state){let n;N(I,{unlocking:!0});try{n=(n=yield null==R?void 0:R.send("eth_requestAccounts",[]))||[]}catch(e){n=[]}if(!(n.length>0))return N(I,{unlocking:!1}),ue=void 0,e=!0,t(!1);{const e=n[0];N(I,{address:e,state:"Ready",unlocking:void 0}),l.log("SETUP_CHAIN from unlock"),yield oe(e,!0)}return ue=void 0,e=!0,t(!0)}return e=!0,n(new Error("Not Locked"))}));return e||(ue=t),t}function pe(){if(l.log("RETRYING..."),N(k,{executionError:void 0}),"Ready"===v.state&&"Ready"===b.state){if(v.contracts){const e=v.contracts;if($){let t;try{l.log("EXECUTING RETRY"),t=$(e)}catch(e){return N(k,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in t)return N(k,{executing:!0}),t.then(()=>($=void 0,N(k,{inProgress:!1,error:void 0,executionError:void 0,executing:!1}),U&&U(e))).catch(e=>(N(k,{executionError:e,executing:!1}),Promise.reject(e)))}return U&&U(e),Promise.resolve()}return Promise.reject("contracts not set")}return"Locked"===b.state?q.flow&&q.flow.autoUnlock&&be().catch(e=>{N(k,{error:e})}):"Idle"===b.state&&1===b.options.length&&q.flow&&q.flow.autoSelect&&fe(b.options[0]).catch(e=>{N(k,{error:e})}),M?M.then(()=>void 0):Promise.resolve()}function we(e,t){return p.inProgress&&_e(),Ie(void 0,e,t)}function ye(e){return Ie(e)}function Ie(e,t,n){if(p.inProgress)throw new Error("flow in progress");if("Ready"===v.state&&"Ready"===b.state&&(!t||t===b.selected)){if(H=void 0,U=void 0,M=void 0,v.contracts){const t=v.contracts;if(e){let n;try{l.log("EXECUTING DIRECT"),n=e(t)}catch(e){return N(k,{executionError:e,executing:!1}),Promise.reject(e)}if("then"in n)return $=e,N(k,{inProgress:!0,error:void 0,executing:!0}),n.then(()=>($=void 0,N(k,{inProgress:!1,error:void 0,executionError:void 0}),t)).catch(e=>(N(k,{executionError:e,executing:!1}),Promise.reject(e)))}return Promise.resolve(t)}return Promise.reject("contracts not set")}return M||($=e,N(k,{inProgress:!0,executing:!1,executionError:void 0,error:void 0}),M=new Promise((e,t)=>{U=e,H=t}),t&&t!==b.selected?b.selected?me({keepFlow:!0}).catch(e=>{N(k,{error:e})}).then(()=>{fe(t,n).catch(e=>{N(k,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),me()})}):fe(t,n).catch(e=>{N(k,{error:{code:11,message:`failed to connect to ${t}`,errorObject:e}}),me()}):"Locked"===b.state?q.flow&&q.flow.autoUnlock&&be().catch(e=>{N(k,{error:e})}):"Idle"===b.state&&1===b.options.length&&q.flow&&q.flow.autoSelect&&fe(b.options[0]).catch(e=>{N(k,{error:e})}),M)}function _e(){H&&H({code:1,message:"Cancel"}),M=void 0,H=void 0,U=void 0,$=void 0,N(k,{inProgress:!1,error:void 0,executionError:void 0,executing:!1})}function xe(e,t,n,o){if(!y.find(e=>e.hash===n.hash))throw new Error("cannot update non-existing Transaction record");Ce(e,t,n,o)}function Ce(e,t,n,o){if(b.address&&b.address.toLowerCase()===e.toLowerCase()&&v.chainId&&t===v.chainId){l.log("TransactionRecord",n);const r=y.find(e=>e.hash===n.hash);if(r){const e=r,t=n;for(const n of Object.keys(t))(o||!o&&void 0===e[n])&&(e[n]=t[n])}else y.push(n);try{localStorage.setItem(E+`_${e.toLowerCase()}_${t}`,JSON.stringify(y))}catch(e){}_.set(y)}else try{const r=E+`_${e.toLowerCase()}_${t}`,i=localStorage.getItem(r)||"[]",a=JSON.parse(i),s=a.find(e=>e.hash===n.hash);if(s){const e=s,t=n;for(const r of Object.keys(n))(!o&&void 0===e[r]||o&&void 0!==t[r])&&(e[r]=t[r])}else a.push(n);localStorage.setItem(r,JSON.stringify(a))}catch(e){}}function Se(){y.splice(0,y.length),_.set(y),ke()}function Pe(e,t){try{const n=localStorage.getItem(E+`_${e.toLowerCase()}_${t}`);let o=[];n&&(o=JSON.parse(n)),y.splice(0,y.length,...o),_.set(y),function(e,t){ke(),Oe(e,t),le=setInterval(()=>Oe(e,t),1e3*q.transactions.pollingPeriod)}(e,t)}catch(e){}}function ke(){le&&(clearInterval(le),le=void 0)}let Ee=!1;function Oe(e,t){return __awaiter(this,void 0,void 0,function*(){if(Ee)return;Ee=!0;const n=q.transactions.finality,o=y.concat();for(const i of o){if(!R)break;if(b.address!==e||v.chainId!==t)break;if(!le)break;let o;try{o=yield R.getBlock("latest")}catch(e){l.error(e);break}if(i.finalized)continue;if(!R)break;if(b.address!==e||v.chainId!==t)break;if(!le)break;let a=0;if(o.number>=n)try{a=yield R.getTransactionCount(e,o.number-Math.max(1,n)+1)}catch(e){l.error(e);break}if(!R)break;if(b.address!==e||v.chainId!==t)break;if(!le)break;let s,c=0;try{c=yield R.getTransactionCount(e)}catch(e){l.error(e);break}if(!R)break;if(b.address!==e||v.chainId!==t)break;if(!le)break;try{s=yield R.getTransactionReceipt(i.hash)}catch(e){l.error(e);continue}if(b.address!==e||v.chainId!==t)break;if(!le)break;const d={hash:i.hash};let u=!1;if(s&&s.blockHash){if(void 0!==s.status){const e=1===s.status;d.status=e?"success":"failure",e&&(d.events=[])}else s.logs.length>0?d.status="success":d.status="mined";if(i.eventsABI&&s.logs.length>0){const e=new r.Interface(i.eventsABI);d.events=s.logs.reduce((t,n)=>{let o;try{o=e.parseLog(n)}catch(e){l.error(e)}if(o){const e={};for(const t of Object.keys(o.args)){const n=o.args[t];e[t]=JSON.parse(JSON.stringify(n))}const n={args:e,name:o.name,signature:o.signature};t.push(n)}return t},[])}d.blockHash=s.blockHash,d.confirmations=s.confirmations,s.confirmations>=n&&(d.finalized=!0,(i.acknowledged||q.transactions.autoDelete)&&(u=!0))}else a>i.nonce?(d.status="cancelled",d.finalized=!0,d.confirmations=Math.max(1,n),(i.acknowledged||q.transactions.autoDelete)&&(u=!0)):c>i.nonce?(d.status="cancelled",d.confirmations=1):(d.status="pending",d.confirmations=0),d.blockHash=void 0,d.blockNumber=void 0,d.events=void 0;if(i.status!==d.status&&(d.acknowledged=!1),u)Ne(i.hash);else{d.lastCheck=o.timestamp;try{xe(e,t,d,!0)}catch(e){l.error(e)}}}Ee=!1})}function Ne(e){if(l.log(`deleting  ${e}`),b.address&&v.chainId){const t=y.findIndex(t=>t.hash===e);y.splice(t,1);try{localStorage.setItem(E+`_${b.address.toLowerCase()}_${v.chainId}`,JSON.stringify(y))}catch(e){}_.set(y)}}t.default=(e=>{(q={builtin:{autoProbe:!!e.builtin&&e.builtin.autoProbe},flow:{autoSelect:!(!e.flow||!e.flow.autoSelect),autoUnlock:!(!e.flow||!e.flow.autoUnlock)},debug:e.debug||!1,chainConfigs:e.chainConfigs,options:e.options||[],autoSelectPrevious:!!e.autoSelectPrevious,localStoragePrefix:e.localStoragePrefix||"",transactions:{autoDelete:!e.transactions||void 0===e.transactions.autoDelete||e.transactions.autoDelete,finality:e.transactions&&e.transactions.finality||12,pollingPeriod:e.transactions&&e.transactions.pollingPeriod||10}}).options&&0!==q.options.length||(q.options=["builtin"]),O=q.localStoragePrefix+O,E=q.localStoragePrefix+E;const{debug:t,chainConfigs:r,builtin:i}=q;if(L=r,e.fallbackNode&&function(e,t){__awaiter(this,void 0,void 0,function*(){const r=new o.JsonRpcProvider(e);let i;N(S,{connecting:!0});try{i=(yield r.getNetwork()).chainId}catch(e){const t={code:u.CHAIN_ID_FAILED,message:"Failed to fetch chainId from fallback"};throw N(S,{error:t,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Idle"}),new Error(t.message)}const a=String(i);N(S,{chainId:a,connecting:!1,loadingData:!1,contracts:void 0,addresses:void 0,state:"Connected"}),N(S,{loadingData:!0}),"function"==typeof t&&(t=yield t(a));const s={},c={};let d;try{d=re(t,a)}catch(e){throw N(S,{error:e,chainId:a,connecting:!1,loadingData:!1,state:"Connected"}),new Error(e.message||e)}for(const e of Object.keys(d)){const t=d[e];t.abi&&(l.log({contractName:e}),s[e]=new n.Contract(t.address,t.abi,r)),c[e]=t.address}N(S,{state:"Ready",loadingData:!1,connecting:!1,chainId:a,addresses:c,contracts:s})})}(e.fallbackNode,r),t&&"undefined"!=typeof window&&(window.$wallet=b,window.$transactions=y),j=q.options,N(I,{state:"Idle",options:j.map(e=>{if("object"==typeof e){if(!e.id)throw new Error("options need to be string or have an id");return e.id}return e})}),N(x,{state:"Idle"}),N(C,{state:"Idle"}),N(P,{state:"Idle"}),g){if(e.autoSelectPrevious){const e=function(){try{return localStorage.getItem(O)}catch(e){return null}}();e&&""!==e&&ce(e)}i.autoProbe&&ge()}return{transactions:{subscribe:_.subscribe,acknowledge(e,t){if(b.address&&v.chainId){const n=y.find(t=>t.hash===e);if(n)if(n.finalized)Ne(e);else{n.lastAcknowledgment=t,n.acknowledged=!0;try{localStorage.setItem(E+`_${b.address.toLowerCase()}_${v.chainId}`,JSON.stringify(y))}catch(e){}_.set(y)}}}},balance:{subscribe:P.subscribe,acknowledgeError:he(P)},chain:{subscribe:C.subscribe,acknowledgeError:he(C),get contracts(){return v.contracts}},fallback:{subscribe:S.subscribe,get contracts(){return m.contracts},get state(){return m.state}},builtin:{subscribe:x.subscribe,acknowledgeError:he(x),probe:ge},wallet:{subscribe:I.subscribe,connect:fe,unlock:be,acknowledgeError:he(I),disconnect:me,get options(){return b.options},get address(){return b.address},get provider(){return R},get web3Provider(){return A},get chain(){return v},get contracts(){return v.contracts},get balance(){return h.amount}},flow:{subscribe:k.subscribe,execute:ye,retry:pe,cancel:_e,connect:we}}})}),define("utils/web",["require","exports"],function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.isPrivateWindow=void 0,t.isPrivateWindow=function(){return new Promise(function(e){if("undefined"!=typeof window)try{if(navigator.vendor&&navigator.vendor.indexOf("Apple")>-1&&navigator.userAgent&&-1==navigator.userAgent.indexOf("CriOS")&&-1==navigator.userAgent.indexOf("FxiOS")){let t=!1;if(window.safariIncognito)t=!0;else try{window.openDatabase(null,null,null,null),window.localStorage.setItem("test",1),e(!1)}catch(n){t=!0,e(!0)}}else if(navigator.userAgent.includes("Firefox")){const t=indexedDB.open("test");t.onerror=function(){e(!0)},t.onsuccess=function(){e(!1)}}else if(navigator.userAgent.includes("Edge")||navigator.userAgent.includes("Trident")||navigator.userAgent.includes("msie"))window.indexedDB||!window.PointerEvent&&!window.MSPointerEvent||e(!0),e(!1);else{(function(){const e=navigator.userAgent.match(/Chrom(?:e|ium)\/([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);if(null!=e&&5==e.length)return e.map(e=>parseInt(e,10))[1]>=76})()&&e(function(){return __awaiter(this,void 0,void 0,function*(){if("storage"in navigator&&"estimate"in navigator.storage){const{quota:e}=yield navigator.storage.estimate();return!!(e&&e<12e7)}return!1})}());const t=window.RequestFileSystem||window.webkitRequestFileSystem;t?t(window.TEMPORARY,100,function(){e(!1)},function(){e(!0)}):e(!1)}}catch(t){console.error(t),e(!1)}else e(!1)})}});